<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue | Bob前端进阶</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="前端工程师,前端自学,高级前端工程师,中高级前端工程师,前端进阶知识,前端职业发展">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a5953812.css" as="style"><link rel="preload" href="/blog/assets/js/app.69e3488a.js" as="script"><link rel="preload" href="/blog/assets/js/2.6a3f7784.js" as="script"><link rel="preload" href="/blog/assets/js/41.cc26419d.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.f0b9ea7c.js"><link rel="prefetch" href="/blog/assets/js/11.5ee70e94.js"><link rel="prefetch" href="/blog/assets/js/12.953bf9cd.js"><link rel="prefetch" href="/blog/assets/js/13.5ecd90f5.js"><link rel="prefetch" href="/blog/assets/js/14.3a71cae0.js"><link rel="prefetch" href="/blog/assets/js/15.df519bc8.js"><link rel="prefetch" href="/blog/assets/js/16.0bfc639b.js"><link rel="prefetch" href="/blog/assets/js/17.024cd9f2.js"><link rel="prefetch" href="/blog/assets/js/18.11c32e89.js"><link rel="prefetch" href="/blog/assets/js/19.7dec9104.js"><link rel="prefetch" href="/blog/assets/js/20.f73f58c1.js"><link rel="prefetch" href="/blog/assets/js/21.968a7f22.js"><link rel="prefetch" href="/blog/assets/js/22.4f55be51.js"><link rel="prefetch" href="/blog/assets/js/23.136f521d.js"><link rel="prefetch" href="/blog/assets/js/24.42cdd0e4.js"><link rel="prefetch" href="/blog/assets/js/25.ff7e97c9.js"><link rel="prefetch" href="/blog/assets/js/26.3a7f9dd0.js"><link rel="prefetch" href="/blog/assets/js/27.df29e08e.js"><link rel="prefetch" href="/blog/assets/js/28.cf8dabe8.js"><link rel="prefetch" href="/blog/assets/js/29.3cace98b.js"><link rel="prefetch" href="/blog/assets/js/3.15ad0de6.js"><link rel="prefetch" href="/blog/assets/js/30.1e1a4ea2.js"><link rel="prefetch" href="/blog/assets/js/31.bb078a51.js"><link rel="prefetch" href="/blog/assets/js/32.a230069c.js"><link rel="prefetch" href="/blog/assets/js/33.c7d1b960.js"><link rel="prefetch" href="/blog/assets/js/34.7c90738d.js"><link rel="prefetch" href="/blog/assets/js/35.1e5b0d61.js"><link rel="prefetch" href="/blog/assets/js/36.417a24b2.js"><link rel="prefetch" href="/blog/assets/js/37.d515a7cf.js"><link rel="prefetch" href="/blog/assets/js/38.88a67386.js"><link rel="prefetch" href="/blog/assets/js/39.71ea29c3.js"><link rel="prefetch" href="/blog/assets/js/4.52e259cf.js"><link rel="prefetch" href="/blog/assets/js/40.23f9ef55.js"><link rel="prefetch" href="/blog/assets/js/42.8b6f8630.js"><link rel="prefetch" href="/blog/assets/js/43.cbf7ab0d.js"><link rel="prefetch" href="/blog/assets/js/44.7fc95863.js"><link rel="prefetch" href="/blog/assets/js/45.debc603b.js"><link rel="prefetch" href="/blog/assets/js/46.adf505d6.js"><link rel="prefetch" href="/blog/assets/js/47.d06f9d26.js"><link rel="prefetch" href="/blog/assets/js/48.d4f27790.js"><link rel="prefetch" href="/blog/assets/js/49.82817914.js"><link rel="prefetch" href="/blog/assets/js/5.4cb81e47.js"><link rel="prefetch" href="/blog/assets/js/50.aab11960.js"><link rel="prefetch" href="/blog/assets/js/51.d35adba8.js"><link rel="prefetch" href="/blog/assets/js/52.cf2b2d3a.js"><link rel="prefetch" href="/blog/assets/js/53.d4185ac2.js"><link rel="prefetch" href="/blog/assets/js/6.58addb6c.js"><link rel="prefetch" href="/blog/assets/js/7.acab10ca.js"><link rel="prefetch" href="/blog/assets/js/8.7110df8a.js"><link rel="prefetch" href="/blog/assets/js/9.70546c31.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a5953812.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Bob前端进阶</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/knowledgeBase/test1.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/knowledgeBase/test4.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/test3.html" class="nav-link">
  功能演示
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="分类" class="mobile-dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/knowledgeBase/test1.html" class="nav-link">
  文章
</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/knowledgeBase/test4.html" class="nav-link">
  琐碎
</a></li></ul></div></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/test3.html" class="nav-link">
  功能演示
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/knowledgeBase/" aria-current="page" class="sidebar-link">知识库</a></li><li><a href="/blog/pages/knowledgeBase/html/" class="sidebar-link">html</a></li><li><a href="/blog/pages/knowledgeBase/css/" class="sidebar-link">css</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>qiankun</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ts</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/knowledgeBase/vue/1.html" aria-current="page" class="active sidebar-link">一、基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#一、vue-基础" class="sidebar-link">一、vue 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_1-vue的基本原理" class="sidebar-link">1. Vue的基本原理</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_2-双向数据绑定的原理" class="sidebar-link">2. 双向数据绑定的原理</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_3-使用-object-defineproperty-来进行数据劫持有什么缺点" class="sidebar-link">3.使用 Object.defineProperty() 来进行数据劫持有什么缺点？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_4-mvvm、mvc、mvp的区别" class="sidebar-link">4. MVVM、MVC、MVP的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_5-computed-和-watch-的区别" class="sidebar-link">5. Computed 和 Watch 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_6-computed-和-methods-的区别" class="sidebar-link">6. Computed 和 Methods 的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_7-slot是什么-有什么作用-原理是什么" class="sidebar-link">7. slot是什么？有什么作用？原理是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_8-过滤器的作用-如何实现一个过滤器" class="sidebar-link">8. 过滤器的作用，如何实现一个过滤器</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_9-如何保存页面的当前的状态" class="sidebar-link">9. 如何保存页面的当前的状态</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_10-常见的事件修饰符及其作用" class="sidebar-link">10. 常见的事件修饰符及其作用</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_13-v-if和v-show的区别" class="sidebar-link">13. v-if和v-show的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_14-v-model-是如何实现的-语法糖实际是什么" class="sidebar-link">14. v-model 是如何实现的，语法糖实际是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_15-v-model-可以被用在自定义组件上吗-如果可以-如何使用" class="sidebar-link">15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_16-data为什么是一个函数而不是对象" class="sidebar-link">16. data为什么是一个函数而不是对象</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_17-对keep-alive的理解-它是如何实现的-具体缓存的是什么" class="sidebar-link">17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_18-nexttick-原理及作用" class="sidebar-link">18. $nextTick 原理及作用</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_19-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="sidebar-link">19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_20-vue中封装的数组方法有哪些-其如何实现页面更新" class="sidebar-link">20. Vue中封装的数组方法有哪些，其如何实现页面更新</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_21-vue-单页应用与多页应用的区别" class="sidebar-link">21. Vue 单页应用与多页应用的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_22-vue-template-到-render-的过程" class="sidebar-link">22. Vue template 到 render 的过程</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_23-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="sidebar-link">23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_24-简述-mixin、extends-的覆盖逻辑" class="sidebar-link">24. 简述 mixin、extends 的覆盖逻辑</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_25-描述下vue自定义指令" class="sidebar-link">25. 描述下Vue自定义指令</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_26-子组件可以直接改变父组件的数据吗" class="sidebar-link">26. 子组件可以直接改变父组件的数据吗？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_27-vue是如何收集依赖的" class="sidebar-link">27. Vue是如何收集依赖的？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_28-对-react-和-vue-的理解-它们的异同" class="sidebar-link">28. 对 React 和 Vue 的理解，它们的异同</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_29-vue的优点" class="sidebar-link">29. Vue的优点</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_30-assets和static的区别" class="sidebar-link">30. assets和static的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_31-delete和vue-delete删除数组的区别" class="sidebar-link">31. delete和Vue.delete删除数组的区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_32-vue如何监听对象或者数组某个属性的变化" class="sidebar-link">32. vue如何监听对象或者数组某个属性的变化</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_33-什么是-mixin" class="sidebar-link">33. 什么是 mixin ？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_34-vue模版编译原理" class="sidebar-link">34. Vue模版编译原理</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_35-对ssr的理解" class="sidebar-link">35. 对SSR的理解</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_36-vue的性能优化有哪些" class="sidebar-link">36. Vue的性能优化有哪些</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_37-对-spa-单页面的理解-它的优缺点分别是什么" class="sidebar-link">37. 对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_38-template和jsx的有什么分别" class="sidebar-link">38. template和jsx的有什么分别？</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_39-vue初始化页面闪动问题" class="sidebar-link">39. vue初始化页面闪动问题</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_40-extend-有什么作用" class="sidebar-link">40. extend 有什么作用</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_41-mixin-和-mixins-区别" class="sidebar-link">41. mixin 和 mixins 区别</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/vue/1.html#_42-mvvm的优缺点" class="sidebar-link">42. MVVM的优缺点?</a></li></ul></li></ul></li><li><a href="/blog/pages/knowledgeBase/vue/2.html" class="sidebar-link">二、生命周期</a></li><li><a href="/blog/pages/knowledgeBase/vue/3.html" class="sidebar-link">三、组件通信</a></li><li><a href="/blog/pages/knowledgeBase/vue/4.html" class="sidebar-link">四、路由</a></li><li><a href="/blog/pages/knowledgeBase/vue/5.html" class="sidebar-link">五、vuex</a></li><li><a href="/blog/pages/knowledgeBase/vue/6.html" class="sidebar-link">六、vue3.0</a></li><li><a href="/blog/pages/knowledgeBase/vue/7.html" class="sidebar-link">七、虚拟DOM</a></li></ul></section></li><li><a href="/blog/pages/knowledgeBase/browser/" class="sidebar-link">浏览器</a></li><li><a href="/blog/pages/knowledgeBase/network/" class="sidebar-link">计算机网络</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/code/" class="sidebar-link">手写代码</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> vue</h1> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>价值不大的知识点不做记录
🎉 💯 🎍 💝 🔥
https://www.webpagefx.com/tools/emoji-cheat-sheet/
https://www.webpagefx.com/tools/emoji-cheat-sheet/</p></div> <h2 id="一、vue-基础"><a href="#一、vue-基础" class="header-anchor">#</a> 一、vue 基础</h2> <h3 id="_1-vue的基本原理"><a href="#_1-vue的基本原理" class="header-anchor">#</a> 1. Vue的基本原理</h3> <p>当一个Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty（vue3.0使用proxy）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b16025a35b4cd2b343a92e740621b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <h3 id="_2-双向数据绑定的原理"><a href="#_2-双向数据绑定的原理" class="header-anchor">#</a> 2. 双向数据绑定的原理</h3> <p>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，<strong>通过Object.defineProperty()来劫持各个属性的setter，getter</strong>，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p> <ul><li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li> <li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li> <li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li> <li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ul> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a286bdc076ae425fb9591bb8c4153240~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <h3 id="_3-使用-object-defineproperty-来进行数据劫持有什么缺点"><a href="#_3-使用-object-defineproperty-来进行数据劫持有什么缺点" class="header-anchor">#</a> 3.使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3> <p>在对一些属性进行操作时，使用这种方法<strong>无法拦截</strong>，
<strong>比如通过下标方式修改数组数据</strong>或者<strong>给对象新增属性</strong>，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p> <p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p> <p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p> <h3 id="_4-mvvm、mvc、mvp的区别"><a href="#_4-mvvm、mvc、mvp的区别" class="header-anchor">#</a> 4. MVVM、MVC、MVP的区别</h3> <p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p> <p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p> <p>（1）MVC</p> <p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65e1b9145894647a25788caf12ddd26~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>（2）MVVM</p> <p>MVVM 分为 Model、View、ViewModel：</p> <p>Model代表数据模型，数据和业务逻辑都在Model层中定义；</p> <p>View代表UI视图，负责数据的展示；</p> <p>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</p> <p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p> <p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p> <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ce15b7b704483eb91ee1f5d1d64786~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p> <p>（3）MVP</p> <p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p> <h3 id="_5-computed-和-watch-的区别"><a href="#_5-computed-和-watch-的区别" class="header-anchor">#</a> 5. Computed 和 Watch 的区别</h3> <p>对于Computed：</p> <ul><li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li> <li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li> <li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li> <li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fullName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
fullName<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>newName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>newName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lastName<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于Watch：</p> <ul><li>它不支持缓存，数据变化时，它就会触发相应的操作</li> <li>支持异步监听</li> <li>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</li> <li>当一个属性发生变化时，就需要执行相应的操作</li> <li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</li> <li>immediate：组件加载立即触发回调函数</li> <li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，<strong>deep无法监听到数组和对象内部的变化。</strong></li></ul> <p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p> <p>总结：</p> <ul><li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。</li> <li>watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li></ul> <p>运用场景：</p> <ul><li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。</li> <li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul> <h3 id="_6-computed-和-methods-的区别"><a href="#_6-computed-和-methods-的区别" class="header-anchor">#</a> 6. Computed 和 Methods 的区别</h3> <p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p> <ul><li><p>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</p></li> <li><p>method 调用总会执行该函数。</p></li></ul> <h3 id="_7-slot是什么-有什么作用-原理是什么"><a href="#_7-slot是什么-有什么作用-原理是什么" class="header-anchor">#</a> 7. slot是什么？有什么作用？原理是什么？</h3> <p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素用来展示分发内容。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p> <ul><li>默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li> <li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽.</li> <li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。v-slot（2.6.0提出）合并了slot和slot-scope，v-slot使得作用域变量和提供它的组件之间的更清晰的联系:</li></ul> <p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default，具名插槽为vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p> <h3 id="_8-过滤器的作用-如何实现一个过滤器"><a href="#_8-过滤器的作用-如何实现一个过滤器" class="header-anchor">#</a> 8. 过滤器的作用，如何实现一个过滤器</h3> <p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用filters来过滤数据，filters不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 computed ，方法 methods 都是通过修改数据来处理数据格式的输出显示）。</p> <p>使用场景：</p> <ul><li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 / 显示。</li> <li>比如后端返回一个 年月日的日期字符串，前端需要展示为 多少天前 的数据格式，此时就可以用fliters过滤器来处理数据。</li></ul> <p>例如，在显示金额，给商品价格添加单位：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>商品价格：<span class="token punctuation">{</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span>price <span class="token operator">|</span> filterPrice<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
filters<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">filterPrice</span> <span class="token punctuation">(</span><span class="token parameter">price</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> price <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token string">'￥'</span> <span class="token operator">+</span> price<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">'--'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_9-如何保存页面的当前的状态"><a href="#_9-如何保存页面的当前的状态" class="header-anchor">#</a> 9. 如何保存页面的当前的状态</h3> <ul><li>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</li> <li>用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行，被包裹在keep-alive中的组件的状态将会被保留.</li> <li>vuex</li></ul> <h3 id="_10-常见的事件修饰符及其作用"><a href="#_10-常见的事件修饰符及其作用" class="header-anchor">#</a> 10. 常见的事件修饰符及其作用</h3> <ul><li>.stop 等价于 event.stopPropation()</li> <li>.prevent 等价于 event.preventDefault()</li> <li>.capture ：与事件冒泡的方向相反，事件捕获由外到内；</li> <li>.self ：只会触发自己范围内的事件，不包含子元素；</li> <li>.once ：只会触发一次。</li></ul> <h3 id="_13-v-if和v-show的区别"><a href="#_13-v-if和v-show的区别" class="header-anchor">#</a> 13. v-if和v-show的区别</h3> <ul><li>手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li> <li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li> <li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li> <li>使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li></ul> <h3 id="_14-v-model-是如何实现的-语法糖实际是什么"><a href="#_14-v-model-是如何实现的-语法糖实际是什么" class="header-anchor">#</a> 14. v-model 是如何实现的，语法糖实际是什么？</h3> <p>（1）作用在表单元素上</p> <p>动态绑定了input的value指向了messgae变量(:value=&quot;message&quot;)，并且在触发input事件(@input)的时候去动态把message设置为目标值(message=$event.target.value)：</p> <p>（2）作用在组件上</p> <p>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件，本质是一个父子组件通信的语法糖，通过prop和$.emit实现。 因此父组件 v-model 语法糖本质上可以修改为：</p> <h3 id="_15-v-model-可以被用在自定义组件上吗-如果可以-如何使用"><a href="#_15-v-model-可以被用在自定义组件上吗-如果可以-如何使用" class="header-anchor">#</a> 15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3> <ul><li>使用 :value.sync + $emit('update:value', val);</li> <li>使用 input + :value + $emit('input', val);</li></ul> <h3 id="_16-data为什么是一个函数而不是对象"><a href="#_16-data为什么是一个函数而不是对象" class="header-anchor">#</a> 16. data为什么是一个函数而不是对象</h3> <p>JavaScript中的对象是引用类型的数据，当多个实例(复用组件)引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p> <h3 id="_17-对keep-alive的理解-它是如何实现的-具体缓存的是什么"><a href="#_17-对keep-alive的理解-它是如何实现的-具体缓存的是什么" class="header-anchor">#</a> 17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3> <p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p> <p>（1）keep-alive</p> <p>keep-alive有以下三个属性：</p> <ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li> <li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li> <li>max 数字，最多可以缓存多少组件实例。</li></ul> <p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p> <ul><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li> <li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li> <li>key生成规则，cid +&quot;∶∶&quot;+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li> <li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。</li> <li>最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ul> <p>（2）keep-alive 的实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> patternTypes<span class="token operator">:</span> Array<span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> RegExp<span class="token punctuation">,</span> Array<span class="token punctuation">]</span> <span class="token comment">// 接收：字符串，正则，数组</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">'keep-alive'</span><span class="token punctuation">,</span>
  abstract<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span>

  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    include<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span> <span class="token comment">// 匹配的组件，缓存</span>
    exclude<span class="token operator">:</span> patternTypes<span class="token punctuation">,</span> <span class="token comment">// 不去匹配的组件，不缓存</span>
    max<span class="token operator">:</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Number<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keys <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">destroyed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 销毁缓存cache的组件实例</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCacheEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cache<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keys<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// prune 削减精简[v.]</span>
    <span class="token comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'include'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$watch</span><span class="token punctuation">(</span><span class="token string">'exclude'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">pruneCache</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">!</span><span class="token function">matches</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p> <p>实现步骤：</p> <ol><li><p>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</p></li> <li><p>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</p></li> <li><p>需要缓存，判断他当前是否在缓存数组里面：</p></li></ol> <ul><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li> <li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li></ul> <ol start="4"><li>最后将这个组件的 keepAlive 设置为 true</li></ol> <p>（3）keep-alive 本身的创建过程和 patch 过程</p> <p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p> <p>首次渲染</p> <p>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/instance/lifecycle</span>
<span class="token keyword">function</span> <span class="token function">initLifecycle</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options

  <span class="token comment">// locate first non-abstract parent</span>
  <span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
    <span class="token punctuation">}</span>
    parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
  vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token operator">:</span> vm

  vm<span class="token punctuation">.</span>$children <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  vm<span class="token punctuation">.</span>$refs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  vm<span class="token punctuation">.</span>_watcher <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_inactive <span class="token operator">=</span> <span class="token keyword">null</span>
  vm<span class="token punctuation">.</span>_directInactive <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
  vm<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>
</code></pre></div><p>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// core/vdom/create-component</span>
<span class="token function">init</span> <span class="token punctuation">(</span>vnode<span class="token operator">:</span> VNodeWithData<span class="token punctuation">,</span> hydrating<span class="token operator">:</span> boolean<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">?</span>boolean <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">&amp;&amp;</span>
    <span class="token operator">!</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_isDestroyed <span class="token operator">&amp;&amp;</span>
    vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive
  <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// componentInstance在初次是undefined!!!</span>
    <span class="token comment">// kept-alive components, treat as a patch</span>
    <span class="token keyword">const</span> mountedNode<span class="token operator">:</span> any <span class="token operator">=</span> vnode <span class="token comment">// work around flow</span>
    componentVNodeHooks<span class="token punctuation">.</span><span class="token function">prepatch</span><span class="token punctuation">(</span>mountedNode<span class="token punctuation">,</span> mountedNode<span class="token punctuation">)</span> <span class="token comment">// prepatch函数执行的是组件更新的过程</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
      vnode<span class="token punctuation">,</span>
      activeInstance
    <span class="token punctuation">)</span>
    child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>hydrating <span class="token operator">?</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p> <p>（4）LRU （least recently used）缓存策略</p> <p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。
LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是 &quot;如果数据最近被访问过，那么将来被访问的几率也更高&quot;。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶</p> <ul><li>新数据插入到链表头部</li> <li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li> <li>链表满的时候，将链表尾部的数据丢弃。</li></ul> <h3 id="_18-nexttick-原理及作用"><a href="#_18-nexttick-原理及作用" class="header-anchor">#</a> 18. $nextTick 原理及作用</h3> <p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p> <p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p> <p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p> <p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p> <ul><li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM 的渲染，可以减少一些无用渲染</li> <li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li></ul> <p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>    <span class="token comment">// 获取数据的操作...})</span>
</code></pre></div><p>所以，在以下情况下，会用到nextTick：</p> <ul><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</li> <li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。</li></ul> <p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</p> <h3 id="_19-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决"><a href="#_19-vue-中给-data-中的对象属性添加一个新的属性时会发生什么-如何解决" class="header-anchor">#</a> 19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</h3> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value in obj<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:key</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span> {{value}} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span> 
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>addObjB<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>添加 obj.b<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span> 
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span> 
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">return</span> <span class="token punctuation">{</span> 
      obj<span class="token operator">:</span> <span class="token punctuation">{</span> 
          a<span class="token operator">:</span> <span class="token string">'obj.a'</span> 
      <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span> 
      <span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token string">'obj.b'</span> 
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span> 
      <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api $set()：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">addObjB</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'obj.b'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p> <h3 id="_20-vue中封装的数组方法有哪些-其如何实现页面更新"><a href="#_20-vue中封装的数组方法有哪些-其如何实现页面更新" class="header-anchor">#</a> 20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3> <p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be20296a76f4e7085dfb510a3211d16~tplv-k3u1fbpfcp-zoom-1.image" alt="">
那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 缓存数组原型</span>
<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
<span class="token comment">// 实现 arrayMethods.__proto__ === Array.prototype</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 需要进行功能拓展的方法</span>
<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">&quot;push&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;pop&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;shift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;unshift&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;splice&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;sort&quot;</span><span class="token punctuation">,</span>
  <span class="token string">&quot;reverse&quot;</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Intercept mutating methods and emit events
 */</span>
methodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存原生数组方法</span>
  <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行并缓存原生数组功能</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 响应式处理</span>
    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>
    <span class="token keyword">let</span> inserted<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// push、unshift会新增索引，所以要手动observer</span>
      <span class="token keyword">case</span> <span class="token string">&quot;push&quot;</span><span class="token operator">:</span>
      <span class="token keyword">case</span> <span class="token string">&quot;unshift&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span>
      <span class="token keyword">case</span> <span class="token string">&quot;splice&quot;</span><span class="token operator">:</span>
        inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取插入的值，并设置响应式监听</span>
    <span class="token comment">// notify change</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 通知依赖更新</span>
    <span class="token comment">// 返回原生数组方法的执行结果</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过target__proto__ == arrayMethods来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p> <h3 id="_21-vue-单页应用与多页应用的区别"><a href="#_21-vue-单页应用与多页应用的区别" class="header-anchor">#</a> 21. Vue 单页应用与多页应用的区别</h3> <p>概念：</p> <ul><li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li> <li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。
区别：
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b3d747986e45e096abaf64faf5e332~tplv-k3u1fbpfcp-zoom-1.image" alt=""></li></ul> <h3 id="_22-vue-template-到-render-的过程"><a href="#_22-vue-template-到-render-的过程" class="header-anchor">#</a> 22. Vue template 到 render 的过程</h3> <p>vue的模版编译过程主要如下：template -&gt; ast -&gt; render函数</p> <p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 将模板编译为render函数</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> staticRenderFns <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">compileToFunctions</span><span class="token punctuation">(</span>template<span class="token punctuation">,</span> options<span class="token comment">//省略}, this)</span>
</code></pre></div><p>CompileToFunctions中的主要逻辑如下∶
（1）调用parse方法将template转化为ast（抽象语法树）</p> <div class="language-js extra-class"><pre class="language-js"><code>constast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre></div><ul><li>parse的目标：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li> <li>解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li></ul> <p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p> <p>（2）调用optimize方法对静态节点做优化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span>options<span class="token punctuation">)</span>
</code></pre></div><p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p> <p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p> <p>（3）生成代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre></div><p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function(<code>render</code>) 生成render函数。</p> <h3 id="_23-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗"><a href="#_23-vue-data-中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗" class="header-anchor">#</a> 23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3> <p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p> <p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p> <h3 id="_24-简述-mixin、extends-的覆盖逻辑"><a href="#_24-简述-mixin、extends-的覆盖逻辑" class="header-anchor">#</a> 24. 简述 mixin、extends 的覆盖逻辑</h3> <p>（1）mixin 和 extends mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p> <ul><li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li> <li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7df745017242a7beaba81e854a0f97~tplv-k3u1fbpfcp-zoom-1.image" alt=""></li></ul> <p>（2）mergeOptions 的执行过程</p> <p>规范化选项（normalizeProps、normalizelnject、normalizeDirectives) 对未合并的选项，进行判断</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">.</span>_base<span class="token punctuation">)</span> <span class="token punctuation">{</span>    
  <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>extends<span class="token punctuation">)</span> <span class="token punctuation">{</span>        
    parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>extends<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>    
  <span class="token punctuation">}</span> 
  <span class="token keyword">if</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>        
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            
      parent <span class="token operator">=</span> <span class="token function">mergeOptions</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> child<span class="token punctuation">.</span>mixins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> vm<span class="token punctuation">)</span>        
    <span class="token punctuation">}</span>    
  <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="_25-描述下vue自定义指令"><a href="#_25-描述下vue自定义指令" class="header-anchor">#</a> 25. 描述下Vue自定义指令</h3> <p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p> <p>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据;</p> <p>（1）自定义指令基本内容</p> <p>全局定义：Vue.directive(&quot;focus&quot;,{})</p> <p>局部定义：directives:{focus:{}}</p> <p>钩子函数：指令定义对象提供钩子函数</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</li> <li>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</li> <li>ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> <p>钩子函数参数</p> <ul><li>el：绑定元素</li> <li>bing： 指令核心对象，描述指令全部信息属性</li> <li>name</li> <li>value</li> <li>oldValue</li> <li>expression</li> <li>arg</li> <li>modifers</li> <li>vnode  虚拟节点</li> <li>oldVnode：上一个虚拟节点（更新钩子函数中才有用）</li></ul> <p>（2）使用场景</p> <ul><li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li> <li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li></ul> <p>（3）使用案例
初级应用：</p> <ul><li>鼠标聚焦</li> <li>下拉菜单</li> <li>相对时间转换</li> <li>滚动动画</li></ul> <p>高级应用：</p> <ul><li>自定义指令实现图片懒加载</li> <li>自定义指令集成第三方插件</li></ul> <h3 id="_26-子组件可以直接改变父组件的数据吗"><a href="#_26-子组件可以直接改变父组件的数据吗" class="header-anchor">#</a> 26. 子组件可以直接改变父组件的数据吗？</h3> <p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p> <p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p> <p>只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <h3 id="_27-vue是如何收集依赖的"><a href="#_27-vue是如何收集依赖的" class="header-anchor">#</a> 27. Vue是如何收集依赖的？</h3> <h3 id="_28-对-react-和-vue-的理解-它们的异同"><a href="#_28-对-react-和-vue-的理解-它们的异同" class="header-anchor">#</a> 28. 对 React 和 Vue 的理解，它们的异同</h3> <h3 id="_29-vue的优点"><a href="#_29-vue的优点" class="header-anchor">#</a> 29. Vue的优点</h3> <h3 id="_30-assets和static的区别"><a href="#_30-assets和static的区别" class="header-anchor">#</a> 30. assets和static的区别</h3> <h3 id="_31-delete和vue-delete删除数组的区别"><a href="#_31-delete和vue-delete删除数组的区别" class="header-anchor">#</a> 31. delete和Vue.delete删除数组的区别</h3> <h3 id="_32-vue如何监听对象或者数组某个属性的变化"><a href="#_32-vue如何监听对象或者数组某个属性的变化" class="header-anchor">#</a> 32. vue如何监听对象或者数组某个属性的变化</h3> <h3 id="_33-什么是-mixin"><a href="#_33-什么是-mixin" class="header-anchor">#</a> 33. 什么是 mixin ？</h3> <h3 id="_34-vue模版编译原理"><a href="#_34-vue模版编译原理" class="header-anchor">#</a> 34. Vue模版编译原理</h3> <h3 id="_35-对ssr的理解"><a href="#_35-对ssr的理解" class="header-anchor">#</a> 35. 对SSR的理解</h3> <h3 id="_36-vue的性能优化有哪些"><a href="#_36-vue的性能优化有哪些" class="header-anchor">#</a> 36. Vue的性能优化有哪些</h3> <h3 id="_37-对-spa-单页面的理解-它的优缺点分别是什么"><a href="#_37-对-spa-单页面的理解-它的优缺点分别是什么" class="header-anchor">#</a> 37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3> <h3 id="_38-template和jsx的有什么分别"><a href="#_38-template和jsx的有什么分别" class="header-anchor">#</a> 38. template和jsx的有什么分别？</h3> <h3 id="_39-vue初始化页面闪动问题"><a href="#_39-vue初始化页面闪动问题" class="header-anchor">#</a> 39. vue初始化页面闪动问题</h3> <h3 id="_40-extend-有什么作用"><a href="#_40-extend-有什么作用" class="header-anchor">#</a> 40. extend 有什么作用</h3> <h3 id="_41-mixin-和-mixins-区别"><a href="#_41-mixin-和-mixins-区别" class="header-anchor">#</a> 41. mixin 和 mixins 区别</h3> <h3 id="_42-mvvm的优缺点"><a href="#_42-mvvm的优缺点" class="header-anchor">#</a> 42. MVVM的优缺点?</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/pages/knowledgeBase/ts/1.html" class="prev">
        ts
      </a></span> <span class="next"><a href="/blog/pages/knowledgeBase/vue/2.html">
        二、生命周期
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.69e3488a.js" defer></script><script src="/blog/assets/js/2.6a3f7784.js" defer></script><script src="/blog/assets/js/41.cc26419d.js" defer></script>
  </body>
</html>
