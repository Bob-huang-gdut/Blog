(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{370:function(t,s,a){"use strict";a.r(s);var n=a(46),_=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"浏览器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[t._v("#")]),t._v(" 浏览器")]),t._v(" "),a("h2",{attrs:{id:"一、浏览器安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、浏览器安全"}},[t._v("#")]),t._v(" 一、浏览器安全")]),t._v(" "),a("h3",{attrs:{id:"_1-什么是-xss-攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是-xss-攻击"}},[t._v("#")]),t._v(" 1.  什么是 XSS 攻击？")]),t._v(" "),a("h4",{attrs:{id:"_1-概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念"}},[t._v("#")]),t._v(" （1）概念")]),t._v(" "),a("p",[t._v("XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。")]),t._v(" "),a("p",[t._v("XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。")]),t._v(" "),a("p",[t._v("攻击者可以通过这种攻击方式可以进行以下操作：")]),t._v(" "),a("ul",[a("li",[t._v("获取页面的数据，如DOM、cookie、localStorage；")]),t._v(" "),a("li",[t._v("DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；")]),t._v(" "),a("li",[t._v("破坏页面结构；")]),t._v(" "),a("li",[t._v("流量劫持（将链接指向某网站）；\n####（2）攻击类型\nXSS 可以分为存储型、反射型和 DOM 型：")]),t._v(" "),a("li",[t._v("存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。")]),t._v(" "),a("li",[t._v("反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。")]),t._v(" "),a("li",[t._v("DOM 型指的通过修改页面的 DOM 节点形成的 XSS。")])]),t._v(" "),a("p",[t._v("1）存储型 XSS 的攻击步骤：")]),t._v(" "),a("ul",[a("li",[t._v("攻击者将恶意代码提交到⽬标⽹站的数据库中。")]),t._v(" "),a("li",[t._v("⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。")]),t._v(" "),a("li",[t._v("⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。")]),t._v(" "),a("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。")])]),t._v(" "),a("p",[t._v("这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。")]),t._v(" "),a("p",[t._v("2）反射型 XSS 的攻击步骤：")]),t._v(" "),a("ul",[a("li",[t._v("攻击者构造出特殊的 URL，其中包含恶意代码。")]),t._v(" "),a("li",[t._v("⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。")]),t._v(" "),a("li",[t._v("⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。")]),t._v(" "),a("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。")])]),t._v(" "),a("p",[t._v("反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。")]),t._v(" "),a("p",[t._v("反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。")]),t._v(" "),a("p",[t._v("3）DOM 型 XSS 的攻击步骤：")]),t._v(" "),a("ul",[a("li",[t._v("攻击者构造出特殊的 URL，其中包含恶意代码。")]),t._v(" "),a("li",[t._v("⽤户打开带有恶意代码的 URL。")]),t._v(" "),a("li",[t._v("⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。")]),t._v(" "),a("li",[t._v("恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。")])]),t._v(" "),a("p",[t._v("DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。")]),t._v(" "),a("h3",{attrs:{id:"_2-如何防御-xss-攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-如何防御-xss-攻击"}},[t._v("#")]),t._v(" 2. 如何防御 XSS 攻击？")]),t._v(" "),a("p",[t._v("可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：")]),t._v(" "),a("ul",[a("li",[t._v("（转义）可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。")]),t._v(" "),a("li",[t._v("（白名单）使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。\nCSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式")]),t._v(" "),a("li",[t._v("（http-only）对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。")])]),t._v(" "),a("h3",{attrs:{id:"_3-什么是-csrf-攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是-csrf-攻击"}},[t._v("#")]),t._v(" 3. 什么是 CSRF 攻击？")]),t._v(" "),a("h4",{attrs:{id:"_1-概念-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-概念-2"}},[t._v("#")]),t._v(" （1）概念")]),t._v(" "),a("p",[t._v("CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。")]),t._v(" "),a("p",[t._v("CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。")]),t._v(" "),a("h4",{attrs:{id:"_2-攻击类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-攻击类型"}},[t._v("#")]),t._v(" （2）攻击类型")]),t._v(" "),a("p",[t._v("常见的 CSRF 攻击有三种：")]),t._v(" "),a("ul",[a("li",[t._v("GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。")]),t._v(" "),a("li",[t._v("POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。")]),t._v(" "),a("li",[t._v("链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。")])]),t._v(" "),a("p",[t._v("CSRF 攻击可以使用以下方法来防护：")]),t._v(" "),a("ul",[a("li",[t._v("（使用origin和referer进行同源检测）进行同源检测，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）")]),t._v(" "),a("li",[t._v("（随机数 Token）使用 CSRF Token 进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。")]),t._v(" "),a("li",[t._v("（Cookie双重验证）对 Cookie 进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。")]),t._v(" "),a("li",[t._v("在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。")])]),t._v(" "),a("h3",{attrs:{id:"_5-什么是中间人攻击-如何防范中间人攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-什么是中间人攻击-如何防范中间人攻击"}},[t._v("#")]),t._v(" 5. 什么是中间人攻击？如何防范中间人攻击？")]),t._v(" "),a("p",[t._v("中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。")]),t._v(" "),a("p",[t._v("攻击过程如下:")]),t._v(" "),a("ul",[a("li",[t._v("客户端发送请求到服务端，请求被中间⼈截获")]),t._v(" "),a("li",[t._v("服务器向客户端发送公钥")]),t._v(" "),a("li",[t._v("中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个"),a("strong",[t._v("伪造")]),t._v("的公钥，发给客户端")]),t._v(" "),a("li",[t._v("客户端收到伪造的公钥后，⽣成加密hash值发给服务器")]),t._v(" "),a("li",[t._v("中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器")]),t._v(" "),a("li",[t._v("服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端")])]),t._v(" "),a("h3",{attrs:{id:"_6-有哪些可能引起前端安全的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-有哪些可能引起前端安全的问题"}},[t._v("#")]),t._v(" 6. 有哪些可能引起前端安全的问题?")]),t._v(" "),a("ul",[a("li",[t._v("跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript / CSS / Flash 等；")]),t._v(" "),a("li",[t._v("iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；")]),t._v(" "),a("li",[t._v("跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击")]),t._v(" "),a("li",[t._v("恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。")])]),t._v(" "),a("h3",{attrs:{id:"_7-网络劫持有哪几种-如何防范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-网络劫持有哪几种-如何防范"}},[t._v("#")]),t._v(" 7. 网络劫持有哪几种，如何防范？")]),t._v(" "),a("p",[t._v("⽹络劫持分为两种:")]),t._v(" "),a("p",[t._v("（1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)")]),t._v(" "),a("p",[t._v("DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器\n302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容")]),t._v(" "),a("p",[t._v("（2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)\nDNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。")]),t._v(" "),a("h2",{attrs:{id:"二、进程与线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、进程与线程"}},[t._v("#")]),t._v(" 二、进程与线程")]),t._v(" "),a("h3",{attrs:{id:"_1-进程与线程的概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程与线程的概念"}},[t._v("#")]),t._v(" 1. 进程与线程的概念")]),t._v(" "),a("p",[t._v("从本质上说，进程和线程都是 CPU 工作时间片的一个描述：")]),t._v(" "),a("ul",[a("li",[t._v("进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。")]),t._v(" "),a("li",[t._v("线程是进程中的更小单位，描述了执行一段指令所需的时间。")])]),t._v(" "),a("p",[t._v("进程是资源分配的最小单位，线程是CPU调度的最小单位。")]),t._v(" "),a("p",[t._v("一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。")]),t._v(" "),a("p",[t._v("如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。")]),t._v(" "),a("p",[t._v("进程和线程之间的关系有以下四个特点：")]),t._v(" "),a("ul",[a("li",[t._v("进程中的任意一线程执行出错，都会导致整个进程的崩溃。")]),t._v(" "),a("li",[t._v("线程之间共享进程中的数据。")]),t._v(" "),a("li",[t._v("当一个进程关闭之后，操作系统会回收进程所占用的内存， 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。")]),t._v(" "),a("li",[t._v("进程之间的内容相互隔离。 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。")])]),t._v(" "),a("p",[t._v("Chrome浏览器的架构图：\n"),a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e928a4f95d4ebe91d0881b5b2cf94b~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),a("p",[t._v("从图中可以看出，最新的 Chrome 浏览器包括：")]),t._v(" "),a("ul",[a("li",[t._v("1 个浏览器主进程")]),t._v(" "),a("li",[t._v("个 GPU 进程")]),t._v(" "),a("li",[t._v("个网络进程")]),t._v(" "),a("li",[t._v("多个渲染进程")]),t._v(" "),a("li",[t._v("多个插件进程")])]),t._v(" "),a("p",[t._v("这些进程的功能：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。")]),t._v(" "),a("li",[t._v("渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。")]),t._v(" "),a("li",[t._v("GPU 进程：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。")]),t._v(" "),a("li",[t._v("网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。")]),t._v(" "),a("li",[t._v("插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。")])]),t._v(" "),a("p",[t._v("所以，打开一个网页，最少需要四个进程：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。")]),t._v(" "),a("p",[t._v("虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：")]),t._v(" "),a("ul",[a("li",[t._v("更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。")]),t._v(" "),a("li",[t._v("更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。")])]),t._v(" "),a("h3",{attrs:{id:"_2-进程和线程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-进程和线程的区别"}},[t._v("#")]),t._v(" 2. 进程和线程的区别")]),t._v(" "),a("ul",[a("li",[t._v("进程可以看做独立应用，线程不能")]),t._v(" "),a("li",[t._v("资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。")]),t._v(" "),a("li",[t._v("通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。")]),t._v(" "),a("li",[t._v("调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。")]),t._v(" "),a("li",[t._v("系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。")])]),t._v(" "),a("h3",{attrs:{id:"_3-浏览器渲染进程的线程有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-浏览器渲染进程的线程有哪些"}},[t._v("#")]),t._v(" 3. 浏览器渲染进程的线程有哪些")]),t._v(" "),a("p",[t._v("浏览器的渲染进程的线程总共有五种：\n"),a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e583f59dc742b9b4e88cf3a3b0f1d4~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),t._v(" "),a("p",[t._v("（1）GUI渲染线程\n负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。\n注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。")]),t._v(" "),a("p",[t._v("（2）JS引擎线程\nJS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；\n注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。")]),t._v(" "),a("p",[t._v("（3）时间触发线程\n时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；\n注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；")]),t._v(" "),a("p",[t._v("（4）定时器触发进程\n定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；\n注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。")]),t._v(" "),a("p",[t._v("（5）异步http请求线程")]),t._v(" "),a("h3",{attrs:{id:"_4-进程之前的通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-进程之前的通信方式"}},[t._v("#")]),t._v(" 4. 进程之前的通信方式")]),t._v(" "),a("p",[t._v("（1）管道通信")]),t._v(" "),a("p",[t._v("管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。")]),t._v(" "),a("p",[t._v("管道的特点：")]),t._v(" "),a("ul",[a("li",[t._v("只能单向通信")]),t._v(" "),a("li",[t._v("只能血缘关系的进程进行通信")]),t._v(" "),a("li",[t._v("依赖于文件系统")]),t._v(" "),a("li",[t._v("生命周期随进程")]),t._v(" "),a("li",[t._v("面向字节流的服务")]),t._v(" "),a("li",[t._v("管道内部提供了同步机制")])]),t._v(" "),a("p",[t._v("（2）消息队列通信")]),t._v(" "),a("p",[t._v("消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。\n使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。")]),t._v(" "),a("p",[t._v("（3）信号量通信")]),t._v(" "),a("p",[t._v("共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。")]),t._v(" "),a("p",[t._v("（4）信号通信")]),t._v(" "),a("p",[t._v("信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。\n（5）共享内存通信")]),t._v(" "),a("p",[t._v("共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。")]),t._v(" "),a("p",[t._v("（6）套接字通信")]),t._v(" "),a("p",[t._v("上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。")]),t._v(" "),a("h3",{attrs:{id:"_5-僵尸进程和孤儿进程是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-僵尸进程和孤儿进程是什么"}},[t._v("#")]),t._v(" 5. 僵尸进程和孤儿进程是什么？")]),t._v(" "),a("ul",[a("li",[t._v("孤儿进程：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。")]),t._v(" "),a("li",[t._v("僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。")])]),t._v(" "),a("h3",{attrs:{id:"_6-死锁产生的原因-如果解决死锁的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-死锁产生的原因-如果解决死锁的问题"}},[t._v("#")]),t._v(" 6. 死锁产生的原因？ 如果解决死锁的问题？")]),t._v(" "),a("p",[t._v("所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。\n系统中的资源可以分为两类：")]),t._v(" "),a("p",[t._v("可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；\n不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。")]),t._v(" "),a("p",[t._v("产生死锁的原因：")]),t._v(" "),a("p",[t._v("（1）竞争资源")]),t._v(" "),a("p",[t._v("产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）\n产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁")]),t._v(" "),a("p",[t._v("（2）进程间推进顺序非法")]),t._v(" "),a("p",[t._v("若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁\n产生死锁的必要条件：")]),t._v(" "),a("p",[t._v("互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。")]),t._v(" "),a("p",[t._v("请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。")]),t._v(" "),a("p",[t._v("预防死锁的方法：")]),t._v(" "),a("p",[t._v("资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）\n只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）\n可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）")]),t._v(" "),a("p",[t._v("资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）")]),t._v(" "),a("h3",{attrs:{id:"_7-如何实现浏览器内多个标签页之间的通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何实现浏览器内多个标签页之间的通信"}},[t._v("#")]),t._v(" 7. 如何实现浏览器内多个标签页之间的通信?")]),t._v(" "),a("p",[t._v("实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：")]),t._v(" "),a("ul",[a("li",[t._v("使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。")]),t._v(" "),a("li",[t._v("使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。")]),t._v(" "),a("li",[t._v("使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。")]),t._v(" "),a("li",[t._v("使用 postMessage 方法，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。(https://www.jianshu.com/p/3d8748f85a06)")])]),t._v(" "),a("h3",{attrs:{id:"_8-对service-worker的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-对service-worker的理解"}},[t._v("#")]),t._v(" 8. 对Service Worker的理解")]),t._v(" "),a("p",[t._v("Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。")]),t._v(" "),a("p",[t._v("Service Worker 实现缓存功能一般分为三个步骤：")]),t._v(" "),a("ul",[a("li",[t._v("首先需要先注册 Service Worker")]),t._v(" "),a("li",[t._v("监听到 install 事件以后就可以缓存需要的文件")]),t._v(" "),a("li",[t._v("下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// index.js")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("navigator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("serviceWorker"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  navigator"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("serviceWorker\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("register")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sw.js'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("registration")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'service worker 注册成功'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'servcie worker 注册失败'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// sw.js")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 监听 `install` 事件，回调中缓存所需文件")]),t._v("\nself"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'install'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("waitUntil")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    caches"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("open")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'my-cache'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("cache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./index.html'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./index.js'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 拦截所有请求事件")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据")]),t._v("\nself"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addEventListener")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fetch'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("e")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("respondWith")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    caches"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("request"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("response")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("response"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" response\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'fetch source'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h3",{attrs:{id:"_9-web-workers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-web-workers"}},[t._v("#")]),t._v(" 9.Web Workers")]),t._v(" "),a("p",[t._v("https://www.jianshu.com/p/45b368bf09cf")]),t._v(" "),a("h2",{attrs:{id:"三、浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、浏览器缓存"}},[t._v("#")]),t._v(" 三、浏览器缓存")]),t._v(" "),a("h3",{attrs:{id:"_1-对浏览器的缓存机制的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-对浏览器的缓存机制的理解"}},[t._v("#")]),t._v(" 1. 对浏览器的缓存机制的理解")]),t._v(" "),a("p",[t._v("浏览器缓存的全过程：")]),t._v(" "),a("ul",[a("li",[t._v("浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；")]),t._v(" "),a("li",[t._v("下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；")]),t._v(" "),a("li",[t._v("如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；")]),t._v(" "),a("li",[t._v("服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；")]),t._v(" "),a("li",[t._v("如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n"),a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})])]),t._v(" "),a("h3",{attrs:{id:"四、浏览器组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、浏览器组成"}},[t._v("#")]),t._v(" 四、浏览器组成")]),t._v(" "),a("h3",{attrs:{id:"五、浏览器渲染原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、浏览器渲染原理"}},[t._v("#")]),t._v(" 五、浏览器渲染原理")]),t._v(" "),a("h3",{attrs:{id:"六、浏览器本地存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、浏览器本地存储"}},[t._v("#")]),t._v(" 六、浏览器本地存储")]),t._v(" "),a("h3",{attrs:{id:"七、浏览器同源策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、浏览器同源策略"}},[t._v("#")]),t._v(" 七、浏览器同源策略")]),t._v(" "),a("h3",{attrs:{id:"八、浏览器事件机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、浏览器事件机制"}},[t._v("#")]),t._v(" 八、浏览器事件机制")]),t._v(" "),a("h4",{attrs:{id:"_10-事件触发的过程是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-事件触发的过程是怎样的"}},[t._v("#")]),t._v(" 10. 事件触发的过程是怎样的")]),t._v(" "),a("p",[t._v("事件触发有三个阶段：")]),t._v(" "),a("h3",{attrs:{id:"九、浏览器垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、浏览器垃圾回收机制"}},[t._v("#")]),t._v(" 九、浏览器垃圾回收机制")]),t._v(" "),a("h4",{attrs:{id:"_1-v8的垃圾回收机制是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-v8的垃圾回收机制是怎样的"}},[t._v("#")]),t._v(" 1. V8的垃圾回收机制是怎样的")]),t._v(" "),a("p",[t._v("V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。")]),t._v(" "),a("p",[t._v("（1）新生代算法")]),t._v(" "),a("p",[t._v("新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。")]),t._v(" "),a("p",[t._v("在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。")]),t._v(" "),a("p",[t._v("（2）老生代算法")]),t._v(" "),a("p",[t._v("老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。")]),t._v(" "),a("p",[t._v("先来说下什么情况下对象会出现在老生代空间中：")]),t._v(" "),a("ul",[a("li",[t._v("新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。")]),t._v(" "),a("li",[t._v("To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。\n老生代中的空间很复杂，有如下几个空间")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" AllocationSpace "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// TODO(v8:7464): Actually map this space's memory as read-only.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 不变的对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代用于 GC 复制算法的空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代常驻对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CODE_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代代码对象空间")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MAP_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代 map 对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老生代大空间对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代大空间对象")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIRST_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LAST_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NEW_LO_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("FIRST_GROWABLE_PAGED_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("OLD_SPACE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LAST_GROWABLE_PAGED_SPACE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MAP_SPACE")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("在老生代中，以下情况会先启动标记清除算法：")]),t._v(" "),a("ul",[a("li",[t._v("某一个空间没有分块的时候")]),t._v(" "),a("li",[t._v("空间中被对象超过一定限制")]),t._v(" "),a("li",[t._v("空间不能保证新生代中的对象移动到老生代中")])]),t._v(" "),a("p",[t._v("在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。")]),t._v(" "),a("p",[t._v("清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。")]),t._v(" "),a("h4",{attrs:{id:"_2-哪些操作会造成内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-哪些操作会造成内存泄漏"}},[t._v("#")]),t._v(" 2. 哪些操作会造成内存泄漏？")]),t._v(" "),a("ul",[a("li",[t._v("第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。")]),t._v(" "),a("li",[t._v("第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。")]),t._v(" "),a("li",[t._v("第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。")]),t._v(" "),a("li",[t._v("第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);