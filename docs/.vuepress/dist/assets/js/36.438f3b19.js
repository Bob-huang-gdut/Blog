(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{408:function(t,s,e){"use strict";e.r(s);var a=e(28),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"_1-react-setstate-调用的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-setstate-调用的原理"}},[t._v("#")]),t._v(" 1. React setState 调用的原理")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e14db0b558d84780b89a8b17b8595cb3~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}}),t._v(" 具体的执行过程如下（源码级解析）：")]),t._v(" "),e("ul",[e("li",[t._v("首先调用了"),e("code",[t._v("setState")]),t._v(" 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ReactComponent.prototype.setState = function (partialState, callback) {\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, 'setState');\n  }\n};\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br")])]),e("ul",[e("li",[e("code",[t._v("enqueueSetState")]),t._v(" 方法将新的 "),e("code",[t._v("state")]),t._v(" 放进组件的状态队列里，并调用 "),e("code",[t._v("enqueueUpdate")]),t._v(" 来处理将要更新的实例对象；")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("enqueueSetState: function (publicInstance, partialState) {\n  // 根据 this 拿到对应的组件实例\n  var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n  // 这个 queue 对应的就是一个组件实例的 state 数组\n  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n  queue.push(partialState);\n  //  enqueueUpdate 用来处理当前的组件实例\n  enqueueUpdate(internalInstance);\n}\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("ul",[e("li",[t._v("在 "),e("code",[t._v("enqueueUpdate")]),t._v(" 方法中引出了一个关键的对象——"),e("code",[t._v("batchingStrategy")]),t._v("，该对象所具备的"),e("code",[t._v("isBatchingUpdates")]),t._v(" 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 "),e("code",[t._v("batchedUpdates")]),t._v(" 方法来直接发起更新流程。由此可以推测，"),e("code",[t._v("batchingStrategy")]),t._v(" 或许正是 React 内部专门用于管控批量更新的对象。")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function enqueueUpdate(component) {\n  ensureInjected();\n  // 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段\n  if (!batchingStrategy.isBatchingUpdates) {\n    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n  // 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br")])]),e("p",[e("strong",[t._v("注意：")]),t._v(" "),e("code",[t._v("batchingStrategy")]),t._v(" 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 "),e("code",[t._v("isBatchingUpdates")]),t._v(" 变量，"),e("code",[t._v("isBatchingUpdates")]),t._v(" 的初始值是 "),e("code",[t._v("false")]),t._v("，意味着“当前并未进行任何批量更新操作”。每当 React 调用 "),e("code",[t._v("batchedUpdate")]),t._v(" 去执行更新动作时，会先把这个锁给“锁上”（置为 "),e("code",[t._v("true")]),t._v("），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 "),e("code",[t._v("dirtyComponents")]),t._v(" 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。")]),t._v(" "),e("h3",{attrs:{id:"_2-react-setstate-调用之后发生了什么-是同步还是异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-react-setstate-调用之后发生了什么-是同步还是异步"}},[t._v("#")]),t._v(" 2. React setState 调用之后发生了什么？是同步还是异步？")]),t._v(" "),e("p",[e("strong",[t._v("（1）React中setState后发生了什么")])]),t._v(" "),e("p",[t._v("在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。")]),t._v(" "),e("p",[t._v("在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。")]),t._v(" "),e("p",[t._v("如果在短时间内频繁setState。React会将state的改变压入栈中，在合适的时机，批量更新state和视图，达到提高性能的效果。")]),t._v(" "),e("p",[e("strong",[t._v("（2）setState 是同步还是异步的")])]),t._v(" "),e("p",[t._v("假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。所以默认是异步的，但是在一些情况下是同步的。")]),t._v(" "),e("p",[t._v("setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而不同。在源码中，通过 isBatchingUpdates 来判断setState 是先存进 state 队列还是直接更新，如果值为 true 则执行异步操作，为 false 则直接更新。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("异步：")]),t._v(" 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。")]),t._v(" "),e("li",[e("strong",[t._v("同步：")]),t._v(" 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。")])]),t._v(" "),e("p",[t._v("一般认为，做异步设计是为了性能优化、减少渲染次数：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("setState")]),t._v("设计为异步，可以显著的提升性能。如果每次调用 "),e("code",[t._v("setState")]),t._v("都进行一次更新，那么意味着"),e("code",[t._v("render")]),t._v("函数会被频繁调用，界面重新渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后进行批量更新；")]),t._v(" "),e("li",[t._v("如果同步更新了"),e("code",[t._v("state")]),t._v("，但是还没有执行"),e("code",[t._v("render")]),t._v("函数，那么"),e("code",[t._v("state")]),t._v("和"),e("code",[t._v("props")]),t._v("不能保持同步。"),e("code",[t._v("state")]),t._v("和"),e("code",[t._v("props")]),t._v("不能保持一致性，会在开发中产生很多的问题；")])]),t._v(" "),e("h3",{attrs:{id:"_3-react中的setstate批量更新的过程是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-react中的setstate批量更新的过程是什么"}},[t._v("#")]),t._v(" 3. React中的setState批量更新的过程是什么？")]),t._v(" "),e("p",[t._v("调用 "),e("code",[t._v("setState")]),t._v(" 时，组件的 "),e("code",[t._v("state")]),t._v(" 并不会立即改变， "),e("code",[t._v("setState")]),t._v(" 只是把要修改的 "),e("code",[t._v("state")]),t._v(" 放入一个队列， "),e("code",[t._v("React")]),t._v(" 会优化真正的执行时机，并出于性能原因，会将 "),e("code",[t._v("React")]),t._v(" 事件处理程序中的多次"),e("code",[t._v("React")]),t._v(" 事件处理程序中的多次 "),e("code",[t._v("setState")]),t._v(" 的状态修改合并成一次状态修改。 最终更新只产生一次组件及其子组件的重新渲染，这对于大型应用程序中的性能提升至关重要。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("this.setState({\n  count: this.state.count + 1    ===>    入队，[count+1的任务]\n});\nthis.setState({\n  count: this.state.count + 1    ===>    入队，[count+1的任务，count+1的任务]\n});\n                                          ↓\n                                         合并 state，[count+1的任务]\n                                          ↓\n                                         执行 count+1的任务\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("p",[t._v("需要注意的是，只要同步代码还在执行，“攒起来”这个动作就不会停止。（注：这里之所以多次 +1 最终只有一次生效，是因为在同一个方法中多次 setState 的合并动作不是单纯地将更新累加。比如这里对于相同属性的设置，React 只会为其保留最后一次的更新）。")]),t._v(" "),e("h3",{attrs:{id:"_4-react中有使用过getdefaultprops吗-它有什么作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-react中有使用过getdefaultprops吗-它有什么作用"}},[t._v("#")]),t._v(" 4. React中有使用过getDefaultProps吗？它有什么作用？")]),t._v(" "),e("p",[t._v("通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法）：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('var ShowTitle = React.createClass({\n  getDefaultProps:function(){\n    return{\n      title : "React"\n    }\n  },\n  render : function(){\n    return <h1>{this.props.title}</h1>\n  }\n});\n\n')])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("h3",{attrs:{id:"_5-react中setstate的第二个参数作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-react中setstate的第二个参数作用是什么"}},[t._v("#")]),t._v(" 5. React中setState的第二个参数作用是什么？")]),t._v(" "),e("p",[e("code",[t._v("setState")]),t._v(" 的第二个参数是一个可选的回调函数。这个回调函数将在组件重新渲染后执行。等价于在 "),e("code",[t._v("componentDidUpdate")]),t._v(" 生命周期内执行。通常建议使用 "),e("code",[t._v("componentDidUpdate")]),t._v(" 来代替此方式。在这个回调函数中你可以拿到更新后 "),e("code",[t._v("state")]),t._v(" 的值：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("this.setState({\n    key1: newState1,\n    key2: newState2,\n    ...\n}, callback) // 第二个参数是 state 更新完成后的回调函数\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("h3",{attrs:{id:"_6-react中的setstate和replacestate的区别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-react中的setstate和replacestate的区别是什么"}},[t._v("#")]),t._v(" 6. React中的setState和replaceState的区别是什么？")]),t._v(" "),e("p",[e("strong",[t._v("（1）setState()")]),t._v(" setState()用于设置状态对象，其语法如下：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("setState(object nextState[, function callback])\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("ul",[e("li",[t._v("nextState，将要设置的新状态，该状态会和当前的state合并")]),t._v(" "),e("li",[t._v("callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。")])]),t._v(" "),e("p",[t._v("合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。")]),t._v(" "),e("p",[e("strong",[t._v("（2）replaceState()")]),t._v(" replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。其语法如下：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("replaceState(object nextState[, function callback])\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("ul",[e("li",[t._v("nextState，将要设置的新状态，该状态会替换当前的state。")]),t._v(" "),e("li",[t._v("callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。")])]),t._v(" "),e("p",[e("strong",[t._v("总结：")]),t._v(" setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。而replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。")]),t._v(" "),e("h3",{attrs:{id:"_7-在react中组件的this-state和setstate有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-在react中组件的this-state和setstate有什么区别"}},[t._v("#")]),t._v(" 7. 在React中组件的this.state和setState有什么区别？")]),t._v(" "),e("p",[t._v("this.state通常是用来初始化state的，this.setState是用来修改state值的。如果初始化了state之后再使用this.state，之前的state会被覆盖掉，如果使用this.setState，只会替换掉相应的state值。所以，如果想要修改state的值，就需要使用setState，而不能直接修改state，直接修改state之后页面是不会更新的。")]),t._v(" "),e("h3",{attrs:{id:"_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-state-是怎么注入到组件的-从-reducer-到组件经历了什么样的过程"}},[t._v("#")]),t._v(" 8. state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程")]),t._v(" "),e("p",[t._v("通过connect和mapStateToProps将state注入到组件中：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import { connect } from 'react-redux'\nimport { setVisibilityFilter } from '@/reducers/Todo/actions'\nimport Link from '@/containers/Todo/components/Link'\n\nconst mapStateToProps = (state, ownProps) => ({\n    active: ownProps.filter === state.visibilityFilter\n})\n\nconst mapDispatchToProps = (dispatch, ownProps) => ({\n    setFilter: () => {\n        dispatch(setVisibilityFilter(ownProps.filter))\n    }\n})\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Link)\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br")])]),e("p",[t._v("上面代码中，active就是注入到Link组件中的状态。 mapStateToProps（state，ownProps）中带有两个参数，含义是∶")]),t._v(" "),e("ul",[e("li",[t._v("state-store管理的全局状态对象，所有都组件状态数据都存储在该对象中。")]),t._v(" "),e("li",[t._v("ownProps 组件通过props传入的参数。")])]),t._v(" "),e("p",[e("strong",[t._v("reducer 到组件经历的过程：")])]),t._v(" "),e("ul",[e("li",[t._v("reducer对action对象处理，更新组件状态，并将新的状态值返回store。")]),t._v(" "),e("li",[t._v("通过connect（mapStateToProps，mapDispatchToProps）（Component）对组件 Component进行升级，此时将状态值从store取出并作为props参数传递到组件。")])]),t._v(" "),e("p",[e("strong",[t._v("高阶组件实现源码∶")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import React from 'react'\nimport PropTypes from 'prop-types'\n\n// 高阶组件 contect \nexport const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => {\n    class Connect extends React.Component {\n        // 通过对context调用获取store\n        static contextTypes = {\n            store: PropTypes.object\n        }\n\n        constructor() {\n            super()\n            this.state = {\n                allProps: {}\n            }\n        }\n\n        // 第一遍需初始化所有组件初始状态\n        componentWillMount() {\n            const store = this.context.store\n            this._updateProps()\n            store.subscribe(() => this._updateProps()); // 加入_updateProps()至store里的监听事件列表\n        }\n\n        // 执行action后更新props，使组件可以更新至最新状态（类似于setState）\n        _updateProps() {\n            const store = this.context.store;\n            let stateProps = mapStateToProps ?\n                mapStateToProps(store.getState(), this.props) : {} // 防止 mapStateToProps 没有传入\n            let dispatchProps = mapDispatchToProps ?\n                mapDispatchToProps(store.dispatch, this.props) : {\n                                    dispatch: store.dispatch\n                                } // 防止 mapDispatchToProps 没有传入\n            this.setState({\n                allProps: {\n                    ...stateProps,\n                    ...dispatchProps,\n                    ...this.props\n                }\n            })\n        }\n\n        render() {\n            return <WrappedComponent {...this.state.allProps} />\n        }\n    }\n    return Connect\n}\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br"),e("span",{staticClass:"line-number"},[t._v("20")]),e("br"),e("span",{staticClass:"line-number"},[t._v("21")]),e("br"),e("span",{staticClass:"line-number"},[t._v("22")]),e("br"),e("span",{staticClass:"line-number"},[t._v("23")]),e("br"),e("span",{staticClass:"line-number"},[t._v("24")]),e("br"),e("span",{staticClass:"line-number"},[t._v("25")]),e("br"),e("span",{staticClass:"line-number"},[t._v("26")]),e("br"),e("span",{staticClass:"line-number"},[t._v("27")]),e("br"),e("span",{staticClass:"line-number"},[t._v("28")]),e("br"),e("span",{staticClass:"line-number"},[t._v("29")]),e("br"),e("span",{staticClass:"line-number"},[t._v("30")]),e("br"),e("span",{staticClass:"line-number"},[t._v("31")]),e("br"),e("span",{staticClass:"line-number"},[t._v("32")]),e("br"),e("span",{staticClass:"line-number"},[t._v("33")]),e("br"),e("span",{staticClass:"line-number"},[t._v("34")]),e("br"),e("span",{staticClass:"line-number"},[t._v("35")]),e("br"),e("span",{staticClass:"line-number"},[t._v("36")]),e("br"),e("span",{staticClass:"line-number"},[t._v("37")]),e("br"),e("span",{staticClass:"line-number"},[t._v("38")]),e("br"),e("span",{staticClass:"line-number"},[t._v("39")]),e("br"),e("span",{staticClass:"line-number"},[t._v("40")]),e("br"),e("span",{staticClass:"line-number"},[t._v("41")]),e("br"),e("span",{staticClass:"line-number"},[t._v("42")]),e("br"),e("span",{staticClass:"line-number"},[t._v("43")]),e("br"),e("span",{staticClass:"line-number"},[t._v("44")]),e("br"),e("span",{staticClass:"line-number"},[t._v("45")]),e("br"),e("span",{staticClass:"line-number"},[t._v("46")]),e("br"),e("span",{staticClass:"line-number"},[t._v("47")]),e("br"),e("span",{staticClass:"line-number"},[t._v("48")]),e("br"),e("span",{staticClass:"line-number"},[t._v("49")]),e("br"),e("span",{staticClass:"line-number"},[t._v("50")]),e("br")])]),e("h3",{attrs:{id:"_9-react组件的state和props有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-react组件的state和props有什么区别"}},[t._v("#")]),t._v(" 9. React组件的state和props有什么区别？")]),t._v(" "),e("p",[e("strong",[t._v("（1）props")])]),t._v(" "),e("p",[t._v("props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。")]),t._v(" "),e("p",[e("strong",[t._v("（2）state")])]),t._v(" "),e("p",[t._v("state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。")]),t._v(" "),e("p",[e("strong",[t._v("（3）区别")])]),t._v(" "),e("ul",[e("li",[t._v("props 是传递给组件的（类似于函数的形参），而state 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。")]),t._v(" "),e("li",[t._v("props 是不可修改的，所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。")]),t._v(" "),e("li",[t._v("state 是在组件中创建的，一般在 constructor中初始化 state。state 是多变的、可以修改，每次setState都异步更新的。")])]),t._v(" "),e("h3",{attrs:{id:"_10-react中的props为什么是只读的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-react中的props为什么是只读的"}},[t._v("#")]),t._v(" 10. React中的props为什么是只读的？")]),t._v(" "),e("p",[e("code",[t._v("this.props")]),t._v("是组件之间沟通的一个接口，原则上来讲，它只能从父组件流向子组件。React具有浓重的函数式编程的思想。")]),t._v(" "),e("p",[t._v("提到函数式编程就要提一个概念：纯函数。它有几个特点：")]),t._v(" "),e("ul",[e("li",[t._v("给定相同的输入，总是返回相同的输出。")]),t._v(" "),e("li",[t._v("过程没有副作用。")]),t._v(" "),e("li",[t._v("不依赖外部状态。")])]),t._v(" "),e("p",[e("code",[t._v("this.props")]),t._v("就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用")]),t._v(" "),e("h3",{attrs:{id:"_11-在react中组件的props改变时更新组件的有哪些方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-在react中组件的props改变时更新组件的有哪些方法"}},[t._v("#")]),t._v(" 11. 在React中组件的props改变时更新组件的有哪些方法？")]),t._v(" "),e("p",[t._v("在一个组件传入的props更新时重新渲染该组件常用的方法是在"),e("code",[t._v("componentWillReceiveProps")]),t._v("中将新的props更新到组件的state中（这种state被成为派生状态（Derived State）），从而实现重新渲染。React 16.3中还引入了一个新的钩子函数"),e("code",[t._v("getDerivedStateFromProps")]),t._v("来专门实现这一需求。")]),t._v(" "),e("p",[e("strong",[t._v("（1）componentWillReceiveProps（已废弃）")])]),t._v(" "),e("p",[t._v("在react的componentWillReceiveProps(nextProps)生命周期中，可以在子组件的render函数执行前，通过this.props获取旧的属性，通过nextProps获取新的props，对比两次props是否相同，从而更新子组件自己的state。")]),t._v(" "),e("p",[t._v("这样的好处是，可以将数据请求放在这里进行执行，需要传的参数则从componentWillReceiveProps(nextProps)中获取。而不必将所有的请求都放在父组件中。于是该请求只会在该组件渲染时才会发出，从而减轻请求负担。")]),t._v(" "),e("p",[e("strong",[t._v("（2）getDerivedStateFromProps（16.3引入）")])]),t._v(" "),e("p",[t._v("这个生命周期函数是为了替代"),e("code",[t._v("componentWillReceiveProps")]),t._v("存在的，所以在需要使用"),e("code",[t._v("componentWillReceiveProps")]),t._v("时，就可以考虑使用"),e("code",[t._v("getDerivedStateFromProps")]),t._v("来进行替代。")]),t._v(" "),e("p",[t._v("两者的参数是不相同的，而"),e("code",[t._v("getDerivedStateFromProps")]),t._v("是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。")]),t._v(" "),e("p",[t._v("需要注意的是，"),e("strong",[t._v("如果props传入的内容不需要影响到你的state，那么就需要返回一个null")]),t._v("，这个返回值是必须的，所以尽量将其写到函数的末尾：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("static getDerivedStateFromProps(nextProps, prevState) {\n    const {type} = nextProps;\n    // 当传入的type发生变化的时候，更新state\n    if (type !== prevState.type) {\n        return {\n            type,\n        };\n    }\n    // 否则，对于state不进行任何操作\n    return null;\n}\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br")])]),e("h3",{attrs:{id:"_12-react中怎么检验props-验证props的目的是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-react中怎么检验props-验证props的目的是什么"}},[t._v("#")]),t._v(" 12. React中怎么检验props？验证props的目的是什么？")]),t._v(" "),e("p",[e("strong",[t._v("React")]),t._v("为我们提供了"),e("strong",[t._v("PropTypes")]),t._v("以供验证使用。当我们向"),e("strong",[t._v("Props")]),t._v("传入的数据无效（向Props传入的数据类型和验证的数据类型不符）就会在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的问题。并且，它还可以让程序变得更易读。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("import PropTypes from 'prop-types';\n\nclass Greeting extends React.Component {\n  render() {\n    return (\n      <h1>Hello, {this.props.name}</h1>\n    );\n  }\n}\n\nGreeting.propTypes = {\n  name: PropTypes.string\n};\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br")])])])}),[],!1,null,null,null);s.default=n.exports}}]);