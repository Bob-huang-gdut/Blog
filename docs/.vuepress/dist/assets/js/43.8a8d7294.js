(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{417:function(s,n,a){"use strict";a.r(n);var e=a(28),t=Object(e.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"_1-react组件命名推荐的方式是哪个"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react组件命名推荐的方式是哪个"}},[s._v("#")]),s._v(" 1. React组件命名推荐的方式是哪个？")]),s._v(" "),a("p",[s._v("通过引用而不是使用来命名组件displayName。")]),s._v(" "),a("p",[s._v("使用displayName命名组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("export default React.createClass({  displayName: 'TodoApp',  // ...})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("React推荐的方法：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("export default class TodoApp extends React.Component {  // ...}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"_2-react-最新版本解决了什么问题-增加了哪些东西"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-react-最新版本解决了什么问题-增加了哪些东西"}},[s._v("#")]),s._v(" 2. react 最新版本解决了什么问题，增加了哪些东西")]),s._v(" "),a("p",[s._v("React 16.x的三大新特性 Time Slicing、Suspense、 hooks")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("Time Slicing（解决CPU速度问题")]),s._v("）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能")]),s._v(" "),a("li",[a("strong",[s._v("Suspense （解决网络IO问题）")]),s._v(" 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式")]),s._v(" "),a("li",[s._v("提供了一个"),a("strong",[s._v("内置函数componentDidCatch")]),s._v("，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件。")])]),s._v(" "),a("p",[a("strong",[s._v("（1）React16.8")]),s._v(" 加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：")]),s._v(" "),a("ul",[a("li",[s._v("在组件间复用状态逻辑很难")]),s._v(" "),a("li",[s._v("复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。")]),s._v(" "),a("li",[s._v("class组件的this指向问题")]),s._v(" "),a("li",[s._v("难以记忆的生命周期")])]),s._v(" "),a("p",[s._v("hooks很好的解决了上述问题，hooks提供了很多方法")]),s._v(" "),a("ul",[a("li",[s._v("useState 返回有状态值，以及更新这个状态值的函数")]),s._v(" "),a("li",[s._v("useEffect 接受包含命令式，可能有副作用代码的函数。")]),s._v(" "),a("li",[s._v("useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，")]),s._v(" "),a("li",[s._v("useReducer useState 的替代方案。接受类型为 （state，action）=> newState的reducer，并返回与dispatch方法配对的当前状态。")]),s._v(" "),a("li",[s._v("useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。")]),s._v(" "),a("li",[s._v("useImperativeMethods 自定义使用ref时公开给父组件的实例值")]),s._v(" "),a("li",[s._v("useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发")]),s._v(" "),a("li",[s._v("useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染")])]),s._v(" "),a("p",[a("strong",[s._v("（2）React16.9")])]),s._v(" "),a("ul",[a("li",[s._v("重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出")]),s._v(" "),a("li",[s._v("废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。")]),s._v(" "),a("li",[s._v('废弃"Factory"组件。 工厂组件会导致 React 变大且变慢。')]),s._v(" "),a("li",[s._v("act（）也支持异步函数，并且你可以在调用它时使用 await。")]),s._v(" "),a("li",[s._v("使用 <React.ProfiLer> 进行性能评估。在较大的应用中追踪性能回归可能会很方便")])]),s._v(" "),a("p",[a("strong",[s._v("（3）React16.13.0")])]),s._v(" "),a("ul",[a("li",[s._v("支持在渲染期间调用setState，但仅适用于同一组件")]),s._v(" "),a("li",[s._v("可检测冲突的样式规则并记录警告")]),s._v(" "),a("li",[s._v("废弃 unstable_createPortal，使用CreatePortal")]),s._v(" "),a("li",[s._v("将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。")])]),s._v(" "),a("h3",{attrs:{id:"_3-react-实现一个全局的-dialog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-react-实现一个全局的-dialog"}},[s._v("#")]),s._v(" 3. react 实现一个全局的 dialog")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import React, { Component } from 'react';\nimport { is, fromJS } from 'immutable';\nimport ReactDOM from 'react-dom';\nimport ReactCSSTransitionGroup from 'react-addons-css-transition-group';\nimport './dialog.css';\nlet defaultState = {\n  alertStatus:false,\n  alertTip:\"提示\",\n  closeDialog:function(){},\n  childs:''\n}\nclass Dialog extends Component{\n  state = {\n    ...defaultState\n  };\n  // css动画组件设置为目标组件\n  FirstChild = props => {\n    const childrenArray = React.Children.toArray(props.children);\n    return childrenArray[0] || null;\n  }\n  //打开弹窗\n  open =(options)=>{\n    options = options || {};\n    options.alertStatus = true;\n    var props = options.props || {};\n    var childs = this.renderChildren(props,options.childrens) || '';\n    console.log(childs);\n    this.setState({\n      ...defaultState,\n      ...options,\n      childs\n    })\n  }\n  //关闭弹窗\n  close(){\n    this.state.closeDialog();\n    this.setState({\n      ...defaultState\n    })\n  }\n  renderChildren(props,childrens) {\n    //遍历所有子组件\n    var childs = [];\n    childrens = childrens || [];\n    var ps = {\n        ...props,  //给子组件绑定props\n        _close:this.close  //给子组件也绑定一个关闭弹窗的事件    \n       };\n    childrens.forEach((currentItem,index) => {\n        childs.push(React.createElement(\n            currentItem,\n            {\n                ...ps,\n                key:index\n            }\n        ));\n    })\n    return childs;\n  }\n  shouldComponentUpdate(nextProps, nextState){\n    return !is(fromJS(this.props), fromJS(nextProps)) || !is(fromJS(this.state), fromJS(nextState))\n  }\n   \n  render(){\n    return (\n      <ReactCSSTransitionGroup\n        component={this.FirstChild}\n        transitionName='hide'\n        transitionEnterTimeout={300}\n        transitionLeaveTimeout={300}>\n        <div className=\"dialog-con\" style={this.state.alertStatus? {display:'block'}:{display:'none'}}>\n            {this.state.childs}\n        </div>\n      </ReactCSSTransitionGroup>\n    );\n  }\n}\nlet div = document.createElement('div');\nlet props = {\n   \n};\ndocument.body.appendChild(div);\nlet Box = ReactD\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br"),a("span",{staticClass:"line-number"},[s._v("58")]),a("br"),a("span",{staticClass:"line-number"},[s._v("59")]),a("br"),a("span",{staticClass:"line-number"},[s._v("60")]),a("br"),a("span",{staticClass:"line-number"},[s._v("61")]),a("br"),a("span",{staticClass:"line-number"},[s._v("62")]),a("br"),a("span",{staticClass:"line-number"},[s._v("63")]),a("br"),a("span",{staticClass:"line-number"},[s._v("64")]),a("br"),a("span",{staticClass:"line-number"},[s._v("65")]),a("br"),a("span",{staticClass:"line-number"},[s._v("66")]),a("br"),a("span",{staticClass:"line-number"},[s._v("67")]),a("br"),a("span",{staticClass:"line-number"},[s._v("68")]),a("br"),a("span",{staticClass:"line-number"},[s._v("69")]),a("br"),a("span",{staticClass:"line-number"},[s._v("70")]),a("br"),a("span",{staticClass:"line-number"},[s._v("71")]),a("br"),a("span",{staticClass:"line-number"},[s._v("72")]),a("br"),a("span",{staticClass:"line-number"},[s._v("73")]),a("br"),a("span",{staticClass:"line-number"},[s._v("74")]),a("br"),a("span",{staticClass:"line-number"},[s._v("75")]),a("br"),a("span",{staticClass:"line-number"},[s._v("76")]),a("br"),a("span",{staticClass:"line-number"},[s._v("77")]),a("br"),a("span",{staticClass:"line-number"},[s._v("78")]),a("br"),a("span",{staticClass:"line-number"},[s._v("79")]),a("br"),a("span",{staticClass:"line-number"},[s._v("80")]),a("br"),a("span",{staticClass:"line-number"},[s._v("81")]),a("br"),a("span",{staticClass:"line-number"},[s._v("82")]),a("br"),a("span",{staticClass:"line-number"},[s._v("83")]),a("br"),a("span",{staticClass:"line-number"},[s._v("84")]),a("br")])]),a("p",[s._v("子类：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('//子类jsx\nimport React, { Component } from \'react\';\nclass Child extends Component {\n    constructor(props){\n        super(props);\n        this.state = {date: new Date()};\n  }\n  showValue=()=>{\n    this.props.showValue && this.props.showValue()\n  }\n  render() {\n    return (\n      <div className="Child">\n        <div className="content">\n           Child\n           <button onClick={this.showValue}>调用父的方法</button>\n        </div>\n      </div>\n    );\n  }\n}\nexport default Child;\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("p",[s._v("css：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(".dialog-con{\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.3);\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h3",{attrs:{id:"_4-react-数据持久化有什么实践吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-数据持久化有什么实践吗"}},[s._v("#")]),s._v(" 4. React 数据持久化有什么实践吗？")]),s._v(" "),a("p",[s._v("封装数据持久化组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("】let storage={\n    // 增加\n    set(key, value){\n        localStorage.setItem(key, JSON.stringify(value));\n    },\n    // 获取\n    get(key){\n        return JSON.parse(localStorage.getItem(key));\n    },\n    // 删除\n    remove(key){\n        localStorage.removeItem(key);\n    }\n};\nexport default Storage;\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("在React项目中，通过redux存储全局数据时，会有一个问题，如果用户刷新了网页，那么通过redux存储的全局数据就会被全部清空，比如登录信息等。这时就会有全局数据持久化存储的需求。首先想到的就是localStorage，localStorage是没有时间限制的数据存储，可以通过它来实现数据的持久化存储。")]),s._v(" "),a("p",[s._v("但是在已经使用redux来管理和存储全局数据的基础上，再去使用localStorage来读写数据，这样不仅是工作量巨大，还容易出错。那么有没有结合redux来达到持久数据存储功能的框架呢？当然，它就是"),a("strong",[s._v("redux-persist")]),s._v("。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。其使用步骤如下：")]),s._v(" "),a("p",[a("strong",[s._v("（1）首先要安装redux-persist：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("npm i redux-persist\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[a("strong",[s._v("（2）对于reducer和action的处理不变，只需修改store的生成代码，修改如下：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import {createStore} from 'redux'\nimport reducers from '../reducers/index'\nimport {persistStore, persistReducer} from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';\nconst persistConfig = {\n    key: 'root',\n    storage: storage,\n    stateReconciler: autoMergeLevel2 // 查看 'Merge Process' 部分的具体情况\n};\nconst myPersistReducer = persistReducer(persistConfig, reducers)\nconst store = createStore(myPersistReducer)\nexport const persistor = persistStore(store)\nexport default store\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[a("strong",[s._v("（3）在index.js中，将PersistGate标签作为网页内容的父标签：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {Provider} from 'react-redux'\nimport store from './redux/store/store'\nimport {persistor} from './redux/store/store'\nimport {PersistGate} from 'redux-persist/lib/integration/react';\nReactDOM.render(<Provider store={store}>\n            <PersistGate loading={null} persistor={persistor}>\n                {/*网页内容*/}\n            </PersistGate>\n        </Provider>, document.getElementById('root'));\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("这就完成了通过redux-persist实现React持久化本地数据存储的简单应用。")]),s._v(" "),a("h3",{attrs:{id:"_5-对-react-和-vue-的理解-它们的异同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-对-react-和-vue-的理解-它们的异同"}},[s._v("#")]),s._v(" 5. 对 React 和 Vue 的理解，它们的异同")]),s._v(" "),a("p",[a("strong",[s._v("相似之处：")])]),s._v(" "),a("ul",[a("li",[s._v("都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库")]),s._v(" "),a("li",[s._v("都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。")]),s._v(" "),a("li",[s._v("都使用了Virtual DOM（虚拟DOM）提高重绘性能")]),s._v(" "),a("li",[s._v("都有props的概念，允许组件间的数据传递")]),s._v(" "),a("li",[s._v("都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性")])]),s._v(" "),a("p",[a("strong",[s._v("不同之处：")])]),s._v(" "),a("p",[a("strong",[s._v("1）数据流")])]),s._v(" "),a("p",[s._v("Vue默认支持数据双向绑定，而React一直提倡单向数据流")]),s._v(" "),a("p",[a("strong",[s._v("2）虚拟DOM")])]),s._v(" "),a("p",[s._v('Vue2.x开始引入"Virtual DOM"，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。')]),s._v(" "),a("ul",[a("li",[s._v("Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。")]),s._v(" "),a("li",[s._v("对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。")])]),s._v(" "),a("p",[a("strong",[s._v("3）组件化")])]),s._v(" "),a("p",[s._v("React与Vue最大的不同是模板的编写。")]),s._v(" "),a("ul",[a("li",[s._v("Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。")]),s._v(" "),a("li",[s._v("React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。")])]),s._v(" "),a("p",[s._v("具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。")]),s._v(" "),a("p",[a("strong",[s._v("4）监听数据变化的实现原理不同")])]),s._v(" "),a("ul",[a("li",[s._v("Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能")]),s._v(" "),a("li",[s._v("React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。")])]),s._v(" "),a("p",[a("strong",[s._v("5）高阶组件")])]),s._v(" "),a("p",[s._v("react可以通过高阶组件（Higher Order Components-- HOC）来扩展，而vue需要通过mixins来扩展。")]),s._v(" "),a("p",[s._v("原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。")]),s._v(" "),a("p",[a("strong",[s._v("6）构建工具")])]),s._v(" "),a("p",[s._v("两者都有自己的构建工具")]),s._v(" "),a("ul",[a("li",[s._v("React ==> Create React APP")]),s._v(" "),a("li",[s._v("Vue ==> vue-cli")])]),s._v(" "),a("p",[a("strong",[s._v("7）跨平台")])]),s._v(" "),a("ul",[a("li",[s._v("React ==> React Native")]),s._v(" "),a("li",[s._v("Vue ==> Weex")])]),s._v(" "),a("h3",{attrs:{id:"_6-可以使用typescript写react应用吗-怎么操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-可以使用typescript写react应用吗-怎么操作"}},[s._v("#")]),s._v(" 6. 可以使用TypeScript写React应用吗？怎么操作？")]),s._v(" "),a("p",[a("strong",[s._v("（1）如果还未创建 Create React App 项目")])]),s._v(" "),a("ul",[a("li",[s._v("直接创建一个具有 typescript 的 Create React App 项目：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v(" npx create-react-app demo --typescript\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[a("strong",[s._v("（2）如果已经创建了 Create React App 项目，需要将 typescript 引入到已有项目中")])]),s._v(" "),a("ul",[a("li",[s._v("通过命令将 typescript 引入项目：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("npm install --save typescript @types/node @types/react @types/react-dom @types/jest\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("将项目中任何 后缀名为 ‘.js’ 的 JavaScript 文件重命名为 TypeScript 文件即后缀名为 ‘.tsx’（例如 src/index.js 重命名为 src/index.tsx ）")])]),s._v(" "),a("h3",{attrs:{id:"_7-react-设计思路-它的理念是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-react-设计思路-它的理念是什么"}},[s._v("#")]),s._v(" 7. React 设计思路，它的理念是什么？")]),s._v(" "),a("p",[a("strong",[s._v("（1）编写简单直观的代码")])]),s._v(" "),a("p",[s._v("React最大的价值不是高性能的虚拟DOM、封装的事件机制、服务器端渲染，而是声明式的直观的编码方式。react文档第一条就是声明式，React 使创建交互式 UI 变得轻而易举。为应用的每一个状态设计简洁的视图，当数据改变时 React 能有效地更新并正确地渲染组件。 以声明式编写 UI，可以让代码更加可靠，且方便调试。")]),s._v(" "),a("p",[a("strong",[s._v("（2）简化可复用的组件")])]),s._v(" "),a("p",[s._v("React框架里面使用了简化的组件模型，但更彻底地使用了组件化的概念。React将整个UI上的每一个功能模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成更大的组件。React的组件具有如下的特性∶")]),s._v(" "),a("ul",[a("li",[s._v("可组合：简单组件可以组合为复杂的组件")]),s._v(" "),a("li",[s._v("可重用：每个组件都是独立的，可以被多个组件使用")]),s._v(" "),a("li",[s._v("可维护：和组件相关的逻辑和UI都封装在了组件的内部，方便维护")]),s._v(" "),a("li",[s._v("可测试：因为组件的独立性，测试组件就变得方便很多。")])]),s._v(" "),a("p",[a("strong",[s._v("（3) Virtual DOM")])]),s._v(" "),a("p",[s._v("真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新。 DOM 操作非常昂贵。在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难 以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 shouldComponentUpdate 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。")]),s._v(" "),a("p",[a("strong",[s._v("（4）函数式编程")])]),s._v(" "),a("p",[s._v("React 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。")]),s._v(" "),a("p",[a("strong",[s._v("（5）一次学习，随处编写")])]),s._v(" "),a("p",[s._v("无论现在正在使用什么技术栈，都可以随时引入 React来开发新特性，而不需要重写现有代码。")]),s._v(" "),a("p",[s._v("React 还可以使用 Node 进行服务器渲染，或使用 React Native 开发原生移动应用。因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。所以，react很方便和其他平台集成")]),s._v(" "),a("h3",{attrs:{id:"_8-react中props-children和react-children的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-react中props-children和react-children的区别"}},[s._v("#")]),s._v(" 8. React中props.children和React.Children的区别")]),s._v(" "),a("p",[s._v("在React中，当涉及组件嵌套，在父组件中使用"),a("code",[s._v("props.children")]),s._v("把所有子组件显示出来。如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function ParentComponent(props){\n\treturn (\n\t\t<div>\n\t\t\t{props.children}\n\t\t</div>\n\t)\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("如果想把父组件中的属性传给所有的子组件，需要使用"),a("code",[s._v("React.Children")]),s._v("方法。")]),s._v(" "),a("p",[s._v("比如，把几个Radio组合起来，合成一个RadioGroup，这就要求所有的Radio具有同样的name属性值。可以这样：把Radio看做子组件，RadioGroup看做父组件，name的属性值在RadioGroup这个父组件中设置。")]),s._v(" "),a("p",[s._v("首先是子组件：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('//子组件\nfunction RadioOption(props) {\n  return (\n    <label>\n      <input type="radio" value={props.value} name={props.name} />\n      {props.label}\n    </label>\n  )\n}\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("然后是父组件，不仅需要把它所有的子组件显示出来，还需要为每个子组件赋上name属性和值：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('//父组件用,props是指父组件的props\nfunction renderChildren(props) {\n    \n  //遍历所有子组件\n  return React.Children.map(props.children, child => {\n    if (child.type === RadioOption)\n      return React.cloneElement(child, {\n        //把父组件的props.name赋值给每个子组件\n        name: props.name\n      })\n    else\n      return child\n  })\n}\n//父组件\nfunction RadioGroup(props) {\n  return (\n    <div>\n      {renderChildren(props)}\n    </div>\n  )\n}\nfunction App() {\n  return (\n    <RadioGroup name="hello">\n      <RadioOption label="选项一" value="1" />\n      <RadioOption label="选项二" value="2" />\n      <RadioOption label="选项三" value="3" />\n    </RadioGroup>\n  )\n}\nexport default App;\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br")])]),a("p",[s._v("以上，"),a("code",[s._v("React.Children.map")]),s._v("让我们对父组件的所有子组件又更灵活的控制。")]),s._v(" "),a("h3",{attrs:{id:"_9-react的状态提升是什么-使用场景有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-react的状态提升是什么-使用场景有哪些"}},[s._v("#")]),s._v(" 9. React的状态提升是什么？使用场景有哪些？")]),s._v(" "),a("p",[s._v("React的状态提升就是用户对子组件操作，子组件不改变自己的状态，通过自己的props把这个操作改变的数据传递给父组件，改变父组件的状态，从而改变受父组件控制的所有子组件的状态，这也是React单项数据流的特性决定的。官方的原话是：共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)”。")]),s._v(" "),a("p",[s._v("概括来说就是"),a("strong",[s._v("将多个组件需要共享的状态提升到它们最近的父组件上")]),s._v("，"),a("strong",[s._v("在父组件上改变这个状态然后通过props分发给子组件。")])]),s._v(" "),a("p",[s._v("一个简单的例子，父组件中有两个input子组件，如果想在第一个输入框输入数据，来改变第二个输入框的值，这就需要用到状态提升。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Father extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            Value1: '',\n            Value2: ''\n        }\n    }\n    value1Change(aa) {\n        this.setState({\n            Value1: aa\n        })\n    }\n    value2Change(bb) {\n        this.setState({\n            Value2: bb\n        })\n    }\n    render() {\n        return (\n            <div style={{ padding: \"100px\" }}>\n                <Child1 value1={this.state.Value1} onvalue1Change={this.value1Change.bind(this)} />\n                \n\n                <Child2 value2={this.state.Value1} />\n            </div>\n        )\n    }\n}\nclass Child1 extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    changeValue(e) {\n        this.props.onvalue1Change(e.target.value)\n    }\n    render() {\n        return (\n            <input value={this.props.Value1} onChange={this.changeValue.bind(this)} />\n        )\n    }\n}\nclass Child2 extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n    render() {\n        return (\n            <input value={this.props.value2} />\n        )\n    }\n}\n \nReactDOM.render(\n    <Father />,\n    document.getElementById('root')\n)\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br"),a("span",{staticClass:"line-number"},[s._v("49")]),a("br"),a("span",{staticClass:"line-number"},[s._v("50")]),a("br"),a("span",{staticClass:"line-number"},[s._v("51")]),a("br"),a("span",{staticClass:"line-number"},[s._v("52")]),a("br"),a("span",{staticClass:"line-number"},[s._v("53")]),a("br"),a("span",{staticClass:"line-number"},[s._v("54")]),a("br"),a("span",{staticClass:"line-number"},[s._v("55")]),a("br"),a("span",{staticClass:"line-number"},[s._v("56")]),a("br"),a("span",{staticClass:"line-number"},[s._v("57")]),a("br")])]),a("h3",{attrs:{id:"_10-react中constructor和getinitialstate的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-react中constructor和getinitialstate的区别"}},[s._v("#")]),s._v(" 10. React中constructor和getInitialState的区别?")]),s._v(" "),a("p",[s._v("两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。")]),s._v(" "),a("p",[s._v("getInitialState是ES5中的方法，如果使用createClass方法创建一个Component组件，可以自动调用它的getInitialState方法来获取初始化的State对象，")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("var APP = React.creatClass ({\n  getInitialState() {\n    return { \n        userName: 'hi',\n        userId: 0\n     };\n　}\n})\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("React在ES6的实现中去掉了getInitialState这个hook函数，规定state在constructor中实现，如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("Class App extends React.Component{\n    constructor(props){\n      super(props);\n      this.state={};\n    }\n  }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"_11-react的严格模式如何使用-有什么用处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-react的严格模式如何使用-有什么用处"}},[s._v("#")]),s._v(" 11. React的严格模式如何使用，有什么用处？")]),s._v(" "),a("p",[a("code",[s._v("StrictMode")]),s._v(" 是一个用来突出显示应用程序中潜在问题的工具。与 "),a("code",[s._v("Fragment")]),s._v(" 一样，"),a("code",[s._v("StrictMode")]),s._v(" 不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告。 可以为应用程序的任何部分启用严格模式。例如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import React from 'react';\nfunction ExampleApplication() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>        \n        <div>\n          <ComponentOne />\n          <ComponentTwo />\n        </div>\n      </React.StrictMode>      \n      <Footer />\n    </div>\n  );\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("在上述的示例中，不会对 "),a("code",[s._v("Header")]),s._v(" 和 "),a("code",[s._v("Footer")]),s._v(" 组件运行严格模式检查。但是，"),a("code",[s._v("ComponentOne")]),s._v(" 和 "),a("code",[s._v("ComponentTwo")]),s._v(" 以及它们的所有后代元素都将进行检查。")]),s._v(" "),a("p",[a("code",[s._v("StrictMode")]),s._v(" 目前有助于：")]),s._v(" "),a("ul",[a("li",[s._v("识别不安全的生命周期")]),s._v(" "),a("li",[s._v("关于使用过时字符串 ref API 的警告")]),s._v(" "),a("li",[s._v("关于使用废弃的 findDOMNode 方法的警告")]),s._v(" "),a("li",[s._v("检测意外的副作用")]),s._v(" "),a("li",[s._v("检测过时的 context API")])]),s._v(" "),a("h3",{attrs:{id:"_12-在react中遍历的方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-在react中遍历的方法有哪些"}},[s._v("#")]),s._v(" 12. 在React中遍历的方法有哪些？")]),s._v(" "),a("p",[a("strong",[s._v("（1）遍历数组：map && forEach")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import React from 'react';\n\nclass App extends React.Component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.map((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n\nclass App extends React.Component {\n  render() {\n    let arr = ['a', 'b', 'c', 'd'];\n    return (\n      <ul>\n        {\n          arr.forEach((item, index) => {\n            return <li key={index}>{item}</li>\n          })\n        }\n      </ul>\n    )\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br")])]),a("p",[a("strong",[s._v("（2）遍历对象：map && for in")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class App extends React.Component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          (() => {\n            let domArr = [];\n            for(const key in obj) {\n              if(obj.hasOwnProperty(key)) {\n                const value = obj[key]\n                domArr.push(<li key={key}>{value}</li>)\n              }\n            }\n            return domArr;\n          })()\n        }\n      </ul>\n    )\n  }\n}\n\n// Object.entries() 把对象转换成数组\nclass App extends React.Component {\n  render() {\n    let obj = {\n      a: 1,\n      b: 2,\n      c: 3\n    }\n    return (\n      <ul>\n        {\n          Object.entries(obj).map(([key, value], index) => {   // item是一个数组，把item解构，写法是[key, value]\n            return <li key={key}>{value}</li>\n          }) \n        }\n      </ul>\n    )\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br")])]),a("h3",{attrs:{id:"_13-在react中页面重新加载时怎样保留数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-在react中页面重新加载时怎样保留数据"}},[s._v("#")]),s._v(" 13. 在React中页面重新加载时怎样保留数据？")]),s._v(" "),a("p",[s._v("这个问题就设计到了"),a("strong",[s._v("数据持久化，")]),s._v(" 主要的实现方式有以下几种：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("Redux：")]),s._v(" 将页面的数据存储在redux中，在重新加载页面时，获取Redux中的数据；")]),s._v(" "),a("li",[a("strong",[s._v("data.js：")]),s._v(" 使用webpack构建的项目，可以建一个文件，data.js，将数据保存data.js中，跳转页面后获取；")]),s._v(" "),a("li",[a("strong",[s._v("sessionStorge：")]),s._v(" 在进入选择地址页面之前，componentWillUnMount的时候，将数据存储到sessionStorage中，每次进入页面判断sessionStorage中有没有存储的那个值，有，则读取渲染数据；没有，则说明数据是初始化的状态。返回或进入除了选择地址以外的页面，清掉存储的sessionStorage，保证下次进入是初始化的数据")]),s._v(" "),a("li",[a("strong",[s._v("history API：")]),s._v(" History API 的 "),a("code",[s._v("pushState")]),s._v(" 函数可以给历史记录关联一个任意的可序列化 "),a("code",[s._v("state")]),s._v("，所以可以在路由 "),a("code",[s._v("push")]),s._v(" 的时候将当前页面的一些信息存到 "),a("code",[s._v("state")]),s._v(" 中，下次返回到这个页面的时候就能从 "),a("code",[s._v("state")]),s._v(" 里面取出离开前的数据重新渲染。react-router 直接可以支持。这个方法适合一些需要临时存储的场景。")])]),s._v(" "),a("h3",{attrs:{id:"_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-同时引用这三个库react-js、react-dom-js和babel-js它们都有什么作用"}},[s._v("#")]),s._v(" 14. 同时引用这三个库react.js、react-dom.js和babel.js它们都有什么作用？")]),s._v(" "),a("ul",[a("li",[s._v("react：包含react所必须的核心代码")]),s._v(" "),a("li",[s._v("react-dom：react渲染在不同平台所需要的核心代码")]),s._v(" "),a("li",[s._v("babel：将jsx转换成React代码的工具")])]),s._v(" "),a("h3",{attrs:{id:"_15-react必须使用jsx吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-react必须使用jsx吗"}},[s._v("#")]),s._v(" 15. React必须使用JSX吗？")]),s._v(" "),a("p",[s._v("React 并不强制要求使用 JSX。当不想在构建环境中配置有关 JSX 编译时，不在 React 中使用 JSX 会更加方便。")]),s._v(" "),a("p",[s._v("每个 JSX 元素只是调用 "),a("code",[s._v("React.createElement(component, props, ...children)")]),s._v(" 的语法糖。因此，使用 JSX 可以完成的任何事情都可以通过纯 JavaScript 完成。")]),s._v(" "),a("p",[s._v("例如，用 JSX 编写的代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Hello extends React.Component {\n  render() {\n    return <div>Hello {this.props.toWhat}</div>;\n  }\n}\nReactDOM.render(\n  <Hello toWhat=\"World\" />,\n  document.getElementById('root')\n);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("可以编写为不使用 JSX 的代码：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Hello extends React.Component {\n  render() {\n    return React.createElement('div', null, `Hello ${this.props.toWhat}`);\n  }\n}\nReactDOM.render(\n  React.createElement(Hello, {toWhat: 'World'}, null),\n  document.getElementById('root')\n);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h3",{attrs:{id:"_16-为什么使用jsx的组件中没有看到使用react却需要引入react"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-为什么使用jsx的组件中没有看到使用react却需要引入react"}},[s._v("#")]),s._v(" 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？")]),s._v(" "),a("p",[s._v("本质上来说JSX是"),a("code",[s._v("React.createElement(component, props, ...children)")]),s._v("方法的语法糖。在React 17之前，如果使用了JSX，其实就是在使用React， "),a("code",[s._v("babel")]),s._v(" 会把组件转换为 "),a("code",[s._v("CreateElement")]),s._v(" 形式。在React 17之后，就不再需要引入，因为 "),a("code",[s._v("babel")]),s._v(" 已经可以帮我们自动引入react。")]),s._v(" "),a("h3",{attrs:{id:"_17-在react中怎么使用async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-在react中怎么使用async-await"}},[s._v("#")]),s._v(" 17. 在React中怎么使用async/await？")]),s._v(" "),a("p",[s._v("async/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。如果是在自己搭建的webpack配置的项目中使用，可能会遇到 "),a("strong",[s._v("regeneratorRuntime is not defined")]),s._v(" 的异常错误。那么我们就需要引入babel，并在babel中配置使用async/await。可以利用babel的 transform-async-to-module-method 插件来转换其成为浏览器支持的语法，虽然没有性能的提升，但对于代码编写体验要更好。")]),s._v(" "),a("h3",{attrs:{id:"_18-react-children-map和js的map有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-react-children-map和js的map有什么区别"}},[s._v("#")]),s._v(" 18. React.Children.map和js的map有什么区别？")]),s._v(" "),a("p",[s._v("JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。")]),s._v(" "),a("h3",{attrs:{id:"_19-对react-ssr的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-对react-ssr的理解"}},[s._v("#")]),s._v(" 19. 对React SSR的理解")]),s._v(" "),a("p",[s._v('服务端渲染是数据与模版组成的html，即 HTML = 数据 ＋ 模版。将组件或页面通过服务器生成html字符串，再发送到浏览器，最后将静态标记"混合"为客户端上完全交互的应用程序。页面没使用服务渲染，当请求页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来;')]),s._v(" "),a("p",[a("strong",[s._v("SSR的优势：")])]),s._v(" "),a("ul",[a("li",[s._v("对SEO友好")]),s._v(" "),a("li",[s._v("所有的模版、图片等资源都存在服务器端")]),s._v(" "),a("li",[s._v("一个html返回所有数据")]),s._v(" "),a("li",[s._v("减少HTTP请求")]),s._v(" "),a("li",[s._v("响应快、用户体验好、首屏渲染快")])]),s._v(" "),a("p",[a("strong",[s._v("1）更利于SEO")])]),s._v(" "),a("p",[s._v("不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本使用了React或者其它MVVM框架之后，页面大多数DOM元素都是在客户端根据js动态生成，可供爬虫抓取分析的内容大大减少。另外，浏览器爬虫不会等待我们的数据完成之后再去抓取页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终HTML，网络爬中就可以抓取到完整页面的信息。")]),s._v(" "),a("p",[a("strong",[s._v("2）更利于首屏渲染")])]),s._v(" "),a("p",[s._v("首屏的渲染是node发送过来的html字符串，并不依赖于js文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间。")]),s._v(" "),a("p",[a("strong",[s._v("SSR的局限：")])]),s._v(" "),a("p",[a("strong",[s._v("1）服务端压力较大")])]),s._v(" "),a("p",[s._v("本来是通过客户端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源;")]),s._v(" "),a("p",[a("strong",[s._v("2）开发条件受限")])]),s._v(" "),a("p",[s._v("在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制;")]),s._v(" "),a("p",[a("strong",[s._v("3）学习成本相对较高")]),s._v(" 除了对webpack、MVVM框架要熟悉，还需要掌握node、 Koa2等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。")]),s._v(" "),a("p",[a("strong",[s._v("时间耗时比较：")])]),s._v(" "),a("p",[a("strong",[s._v("1）数据请求")])]),s._v(" "),a("p",[s._v('由服务端请求首屏数据，而不是客户端请求首屏数据，这是"快"的一个主要原因。服务端在内网进行请求，数据响应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差')]),s._v(" "),a("ul",[a("li",[s._v("客户端数据请求")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0ce3fdd27549adb9abf9c5850383d5~tplv-k3u1fbpfcp-zoom-1.image",alt:"51612599334_.pic.jpg"}})]),s._v(" "),a("ul",[a("li",[s._v("服务端数据请求")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d04305fb2097482dbdf317e617fd2ea7~tplv-k3u1fbpfcp-zoom-1.image",alt:"61612599340_.pic.jpg"}}),s._v(" "),a("strong",[s._v("2）html渲染")]),s._v(" 服务端渲染是先向后端服务器请求数据，然后生成完整首屏 html返回给浏览器；而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。")]),s._v(" "),a("ul",[a("li",[s._v("非ssr html渲染")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c89c6af3ece348a7b85b7d9b01bdb6a9~tplv-k3u1fbpfcp-zoom-1.image",alt:"31612599269_.pic.jpg"}})]),s._v(" "),a("ul",[a("li",[s._v("ssr html渲染")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45bc5a6af17414388e7ccf815ff1be6~tplv-k3u1fbpfcp-zoom-1.image",alt:"41612599275_.pic.jpg"}})]),s._v(" "),a("h3",{attrs:{id:"_20-为什么-react-要用-jsx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-为什么-react-要用-jsx"}},[s._v("#")]),s._v(" 20. 为什么 React 要用 JSX？")]),s._v(" "),a("p",[s._v("JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。")]),s._v(" "),a("p",[s._v("其实 React 本身并不强制使用 JSX。在没有 JSX 的时候，React 实现一个组件依赖于使用 React.createElement 函数。代码如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Hello extends React.Component {\n  render() {\n    return React.createElement(\n        'div',\n        null, \n        `Hello ${this.props.toWhat}`\n      );\n  }\n}\nReactDOM.render(\n  React.createElement(Hello, {toWhat: 'World'}, null),\n  document.getElementById('root')\n);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("而 JSX 更像是一种语法糖，通过类似 XML 的描述方式，描写函数对象。在采用 JSX 之后，这段代码会这样写：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Hello extends React.Component {\n  render() {\n    return <div>Hello {this.props.toWhat}</div>;\n  }\n}\nReactDOM.render(\n  <Hello toWhat=\"World\" />,\n  document.getElementById('root')\n);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("通过对比，可以清晰地发现，代码变得更为简洁，而且代码结构层次更为清晰。")]),s._v(" "),a("p",[s._v("因为 React 需要将组件转化为虚拟 DOM 树，所以在编写代码时，实际上是在手写一棵结构树。而"),a("strong",[s._v("XML 在树结构的描述上天生具有可读性强的优势。")])]),s._v(" "),a("p",[s._v("但这样可读性强的代码仅仅是给写程序的同学看的，实际上在运行的时候，会使用 Babel 插件将 JSX 语法的代码还原为 React.createElement 的代码。")]),s._v(" "),a("p",[a("strong",[s._v("总结：")]),s._v(" JSX 是一个 JavaScript 的语法扩展，结构类似 XML。JSX 主要用于声明 React 元素，但 React 中并不强制使用 JSX。即使使用了 JSX，也会在构建过程中，通过 Babel 插件编译为 React.createElement。所以 JSX 更像是 React.createElement 的一种语法糖。")]),s._v(" "),a("p",[s._v("React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。")]),s._v(" "),a("h3",{attrs:{id:"_21-hoc相比-mixins-有什么优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-hoc相比-mixins-有什么优点"}},[s._v("#")]),s._v(" 21. HOC相比 mixins 有什么优点？")]),s._v(" "),a("p",[s._v("HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：")]),s._v(" "),a("ul",[a("li",[s._v("隐含了一些依赖，比如我在组件中写了某个 "),a("code",[s._v("state")]),s._v(" 并且在 "),a("code",[s._v("mixin")]),s._v(" 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 "),a("code",[s._v("mixin")]),s._v(" 中查找依赖")]),s._v(" "),a("li",[s._v("多个 "),a("code",[s._v("mixin")]),s._v(" 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。")]),s._v(" "),a("li",[s._v("雪球效应，虽然我一个组件还是使用着同一个 "),a("code",[s._v("mixin")]),s._v("，但是一个 "),a("code",[s._v("mixin")]),s._v(" 会被多个组件使用，可能会存在需求使得 "),a("code",[s._v("mixin")]),s._v(" 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本")])]),s._v(" "),a("p",[s._v("HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。")]),s._v(" "),a("h3",{attrs:{id:"_22-react-中的高阶组件运用了什么设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-react-中的高阶组件运用了什么设计模式"}},[s._v("#")]),s._v(" 22. React 中的高阶组件运用了什么设计模式？")]),s._v(" "),a("p",[s._v("使用了装饰模式，高阶组件的运用：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("function withWindowWidth(BaseComponent) {\n  class DerivedClass extends React.Component {\n    state = {\n      windowWidth: window.innerWidth,\n    }\n    onResize = () => {\n      this.setState({\n        windowWidth: window.innerWidth,\n      })\n    }\n    componentDidMount() {\n      window.addEventListener('resize', this.onResize)\n    }\n    componentWillUnmount() {\n      window.removeEventListener('resize', this.onResize);\n    }\n    render() {\n      return <BaseComponent {...this.props} {...this.state}/>\n    }\n  }\n  return DerivedClass;\n}\nconst MyComponent = (props) => {\n  return <div>Window width is: {props.windowWidth}</div>\n};\nexport default withWindowWidth(MyComponent);\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br")])]),a("p",[s._v("装饰模式的特点是不需要改变 被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，其用法如下：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("@testable\n   class MyTestableClass {\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])])])}),[],!1,null,null,null);n.default=t.exports}}]);