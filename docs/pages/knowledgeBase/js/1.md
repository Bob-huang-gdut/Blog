# js基础知识

::: tip 提示
价值不大的知识点不做记录
:tada: :100: :bamboo: :gift_heart: :fire:
https://www.webpagefx.com/tools/emoji-cheat-sheet/
https://www.webpagefx.com/tools/emoji-cheat-sheet/
:::

## 基础变量
- 基本类型有六种： Boolean, String, Number, Null, Undefined, Symbol
- Object(在JS中除了基本数据类型以外的都是对象，Date, function, Array, 正则表达式都是对象)
- Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值。

## this指向问题
- 在全局范围内，this指向全局对象
- this的指向取决于执行时上下文环境
- 可以使用bind，call，apply去改变执行的上下文环境，bind是提供了一个可执行的函数，但是本身并不会执行，需要我们手动去执行；call和apply它们是提供了一个可立即执行的函数，在绑定this的同时，也会立即去执行该函数。这也是为什么我们在最后一个bind方法中再次需要的单独再调用一次funb()方法的原因。

## 原型继承原理
一般，每个对象都会有一个原型__proto__，这个原型也会有自己的原型，将这些原型连接起来就形成了原型链，在查找特定属性时，会先去对象里面找，如果没有再去原型对象上找，如果没有的话会委托给上层的原型链继续查找。
```js
// 1.构造函数Example
function Example() {}
// 2.构造函数Example的prototype属性指向Example.prototype
// 3.构造函数Example的原型Example.prototype的constructor属性指向构造函数Example
Example = Example.prototype.constructor
// 4.使用构造函数Example new实例化 exampleOne
const exampleOne = new Example()
// 5.exampleOne的__proto__属性指向构造函数的原型Example.prototype
exampleOne.__proto__ = Example.prototype
```
```js
// 6.Example.prototype的__proto__属性指向Object.prototype，
Example.__proto__ = Object.prototype
// 7.构造函数Object的prototype属性指向Object.prototype
// 8.构造函数Object的原型Object.prototype的constructor属性指向构造函数Object
Object = Object.prototype.constructor
// 9.Object.prototype的__proto__属性指向Null
Object.prototype.__proto__ = Null
```
```js
// Function在原型链中的作用
```
```js
// 例子
function Example(){}
var ExampleOne = new Example(); //new实例化
console.log(ExampleOne.__proto__ === Example.prototype); // true
console.log(Example.prototype.__proto__ === Object.prototype) //true
console.log(Object.prototype.__proto__) //null

Example.__proto__ == Function.prototype; //true
console.log(Function.prototype)// function(){} (这是个空函数)

var number = new Array()
console.log(number.__proto__ == Array.prototype) // true
console.log( Array.prototype.__proto__ == Object.prototype) // true
console.log(Array.prototype) // [] (这是个空数组)
console.log(Object.prototype.__proto__) //null

console.log(Array.__proto__ == Function.prototype)// true
```
- __proto__是对象的属性，prototype是构造函数的属性，__proto__总指向prototype;
- prototype在构造函数创建时会自动生成，它总会被__proto__指向。

## 作用域
变量的作用域一般分为两种：全局作用域和局部作用域。
```js
var num1 = 1;
function one() {
  console.log(num1);  // undefined，（在局部作用域声明了num1之后，num1这个变量会提升）
  var num1 = 2;
  console.log(num1) // 2
}
```
- var：如果在当前函数内部声明一个变量，则作用范围在函数内部(没有块级作用域)；如果在最外层声明，则作为全局变量；如果未使用var定义直接使用变量，则会报错；
- const：具有块级作用域的特征，同一个作用域中，变量名只能声明一次，不存在变量提升。const声明的变量必须是个常量。
- let： 跟const几乎类似，但是最主要的区别是let声明的是一个变量，const声明的必须是个常量。

不同之处
- var存在变量提升，let和const不会；
- var在函数内部同一个变量可以重复声明，而在同一个块级作用域内部，let和const只能声明一次，并且const声明的是个常量，不能修改；
- var 声明的变量属于函数作用域，let 和 const 声明的变量属于块级作用域

::: demo [vanilla]
```html
<script>
  // if (true) {
  //   var name1 = 'name'
  //   let name2 = 'name2'
  //   const name3;
  //   console.log(name3)
  //   name3 = 'name3'  
  // }
  // console.log(name1)
  // console.log(name2)
</script>
```
:::

## 闭包
作用：是能够读取其他函数内部变量的函数，使得函数不被GC回收，可以避免使用全局变量，但是过多使用会造成内存泄露。
```js
function f1() {
  var val1 = 100
  return function() {
    return ++val1
  }
}
var fn = f1();
fn() // 100
fn() // 101
```

## 什么是事件委托以及冒泡事件和默认事件如何阻止？

- 冒泡阻止方式：使用event.cancelBubble = true或者event.stopPropgation()（低于IE9）。

- 默认事件阻止方式： e.preventDefault(); 或return false;。

## 如何检查一个数字是否为整数？
```js
function isInt(number) {
  return number % 1 === 0;
};
console.log(isInt(2.1));  // false
console.log(isInt(2));  // true
```

## Javascript的事件流模型都有什么?
事件捕捉，目标阶段，事件冒泡

## jsonp的原理，以及为什么不是真正的ajax?
Jsonp原理： 利用浏览器可以动态的插入一段JS代码并执行；

为什么不是真正的AJAX
- 首先，ajax和jsonp在调用方式上虽然长得差不多（目的一样，都是请求一个url，然后把服务器返回的数据进行处理），但是ajax和jsonp本质上是不同的东西;
- 哪里不同？核心不同！ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本;
```js
// 前端
<script type='text/javascript'>
  window.jsonpCallback = function (res) {
    console.log(res)
  }
</script>
<script src='http://localhost:8080/api/jsonp?id=1&cb=jsonpCallback' type='text/javascript'></script>
```
```js
// 后端
const Koa = require('koa');
const app = new Koa();
const items = [{ id: 1, title: 'title1' }, { id: 2, title: 'title2' }]

app.use(async (ctx, next) => {
  if (ctx.path === '/api/jsonp') {
    const { cb, id } = ctx.query;
    const title = items.find(item => item.id == id)['title']
    ctx.body = `${cb}(${JSON.stringify({title})})`;
    return;
  }
})
console.log('listen 8080...')
app.listen(8080);
```

## new操作符具体干了些啥？
首先我们需要明白的是：new关键字主要的作用还是在于继承。

对于const a = new Foo();，new干的事情。如下代码：
- 创建一个空对象；
```js
const obj = new Foo();
```
- 设置原型链
```js
obj.__proto__ = Person.prototype
```
- 让Func的this指向obj，并执行Func函数体；
```js
Person.call(obj)
```
- 将obj对象赋值给person对象，判断Func（构造函数）的返回值类型；
```js
person = obj
```

## script属性的defer标签和async标签的区别？
- 不加属性
- defer属性（页面load后执行）：脚本会被延迟到整个页面都解析完毕之后再执行。若是设置了defer属性，就等于**告诉浏览器立即下载，但是会延迟执行。注意defer属性只适用于外部脚本文件。**
- async属性（页面load前执行）：为了不让页面等待脚本下载和执行，异步加载页面和其他内容。async同样也只适用于外部文件（不会影响页面加载，但是不能控制加载的顺序）

![](https://e.im5i.com/2021/07/05/KtZgS.png)

总结：
- 下载是并行，执行时机不同，defer是页面加载完后，保证执行顺序，async是加载完后就执行，不能保证执行顺序

## 线程与进程的区别？
一个程序至少有一个进程，一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。这里我们可以简单的把进程理解成火车，线程理解为车厢。

- 线程在进程下运行，不能单独运行（单纯的一节节车厢无法运行）；
- 一个进程可以包含多个线程（一辆火车有很多车厢）；
- 不同进程之间的数据难以共享（列车在行驶时，乘客很难从一列火车换到另一列火车）；
- 同一进程下的线程数据共享便捷（乘客在同一列火车上从一节车厢换到另一节很方便）；
- 进程要比线程花费更多的计算机资源（车厢仅仅是跑，火车还要发动动力带它跑，花的力气更多）；
- 进程之间互不影响，但是同一个进程中要是有一个线程出现问题将导致整个进程有问题（一辆类车要是某一节车厢出问题比如起火，会导致火车暂停）；
- 进程可以拓展到多机，而线程最多扩展到多核cpu。（不同的火车可以开在不同的轨道上，而同一火车的车厢只能形式在当前火车行驶的轨道上）；
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束才能使用这块内存。（例如使用火车上的洗手间-“互斥锁”）；
- 进程使用的内存地址可以限定使用量（例如火车上的卧铺，最多只允许多少个人睡，如果安排满了就需要等待，待有空床位出来了才能进去--“信号量”）；

## document load 和document ready的区别
- document load：是在结构和样式，外部js和图片加载完才执行js；
- document ready： 是dom树创建完成就执行的方法，原生是没有这种方法的。

## 如何中断ajax请求
- 设置超时时间让ajax自动断开；
- 手动停止ajax请求，其核心是调用XML对象的abort方法，ajax.abort()；

## 事件循环 (event loop)，宏任务和微任务

## get和post的区别

## 常见的http的响应码及含义
(1)、1xx（临时响应）

- 100: 请求者应当继续提出请求。
- 101(切换协议): 请求者已要求服务器切换协议，服务器已确认并准备进行切换。

(2)、2xx（成功）

- 200: 请求成功并返回正确接口结果；
- 201: 表示资源被正确创建。
- 202: 请求正确，但结果正在处理中，这时候客户端可以通过轮询等机制继续请求。
- 203: 非授权信息，服务器已成功处理了请求，但返回的信息可能来自另一个源；
- 204: 无内容，服务器成功处理了请求，但没有返回任何内容；
- 205: 重置内容，服务器成功处理了请求，内容被重置；
- 206: 部分内容，服务器成功处理了部分请求；

(3)、3xx（已重定向）

- 300: 已经请求成功，但是有多个结果返回；
- 301: 请求成功，但是资源被永久转移；
- 302: 临时移动，请求的网页暂时跳转到其他页面，即暂时重定向；
- 303: 使用get访问新的地址来获取资源;
- 304: 请求的资源并没有被修改过;
- 305: 使用代理，请求者应该使用代理访问该页面；
- 306: 临时重定向，请求的资源临时从其他位置响应；

(4)、4xx(请求错误)

- 400: 请求出现错误，比如请求头不对等；
- 401: 没有提供认证信息。请求的时候没有带上 Token 等；
- 402: 为以后需要所保留的状态码；
- 403: 请求的资源不允许访问，无权限；
- 404: 访问页面不存在；
- 405: 方法禁用，服务器禁用了请求中指定的方法；
406：不接受，无法使用请求的内容响应请求的页面；
- 407: 请求者需要使用代理授权；
- 408: 服务器请求超时；
- 409: 服务器在完成请求时发生冲突；
410：请求的资源已永久删除；
- 411: 需要有效长度。服务器不接受不含有效内容长度标头字段的请求；
- 412: 服务器未满足请求者在请求中设置的其中一个前提条件；
- 413: 请求实体过大，超出服务器的处理能力；
- 414: 请求网址过长，服务器无法处理；
- 415: 请求格式不被请求页面支持；
- 416: 页面无法提供请求的范围;
- 417: 服务器未满足期望请求标头字段的要求;

(5)、5xx（服务器错误）

- 500: 服务器内部错误，无法完成请求；
- 501: 请求还没有被实现，服务器不具备完整的请求功能；
- 502: 错误网关，服务器作为网关或代理，从上游服务器收到无效响应；
- 503: 服务不可用；
- 504: 网关超时，服务器作为网关或代理。但是没有及时从上游服务器收到请求；
- 505: HTTP版本不支持，服务器不支持请求中所用的HTTP协议版本。

## IE和DOM事件流的区别
- 从执行顺序看： IE采用的是冒泡型事件，而DOM是先捕获后冒泡事件；
```js
<body> 
<div> 
<button>点击</button> 
</div> 
</body> 

// 冒泡型事件模型： button->div->body (IE事件流) 
// 捕获型事件模型： body->div->button (Netscape事件流) 
// DOM事件模型： body->div->button->button->div->body (先捕获后冒泡) 
```
- 从第一个参数是否加"on"问题看,低版本IE不支持addEventListener(),支持attachEvent,第一个参数需要加on；
- 从this的指向问题看，IE指向windows,不指向触发的函数；

## 如何实现多个标签之间的通信
1.调用 localStorage:
- 在一个标签内使用localStorage。setItem(key, value)添加（删除或修改）内容；
- 在另一个标签页面监听storage事件；window.addEventListener("storage", showStorage);
- 得到localStorage存储的值，即可实现不用页面之间的通信
2.调用 cookie+setInterval():
- 将要传递的信息存储在cookie中，可以设置定时读取cookie的信息，即可随时获取想要传递的信息。
3.使用 Webworker:
- webworker作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码，并且对浏览器用户界面不影响；
- 普通的Webworker用 new worker()即可创建，这种webworker是当前页面专有的。然后还有种共享worker(SharedWorker)，这种是可以多个标签页、iframe共同使用.

## 哪些操作会造成内存泄露
- 过量使用闭包会引起内存泄露（解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用）；
- 控制台日志（解决：项目完成后记得删除多余的控制台打印）；
- 循环，也就是两个对象彼此引用且彼此保留；(递归引用)
- setTimeout的第一个参数是字符串而不是函数的时候也会造成内存泄露（解决：尽量不要将第一个参数定义为字符串）；
- 意外的全局变量也会引起内存泄漏（解决：使用严格模式避免）。
- 没有清理DOM元素（解决：手动删除）；

## js垃圾回收的几种方式
javascript具有自动垃圾回收机制，垃圾器回收会按照固定的时间间隔周期性的执行。

常见的垃圾回收机制有两种： 标记清除，引用计数。

**标记清除**

原理： 当变量进入环境时，将这个变量标记为“进入环境”。当变量离开时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：
- 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记；