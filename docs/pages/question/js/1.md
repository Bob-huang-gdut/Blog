# 代码输出题

代码输出结果是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：**异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承等**，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。

## 异步&事件循环

### 1
```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
```
输出结果
```js
1 
2 
4
undefined
```
promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。

### 2
```js
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
```
输出结果如下：
```js
promise1
1 Promise{<resolved>: resolve1}
2 Promise{<pending>}
resolve1
```
代码执行过程如下：

- script是一个宏任务，按照顺序执行这些代码；
- 首先进入Promise，执行该构造函数中的代码，打印promise1；
- 碰到resolve函数, 将promise1的状态改变为resolved, 并将结果保存下来；
- 碰到promise1.then这个微任务，将它放入微任务队列；
- promise2是一个新的状态为pending的Promise；
- 执行同步代码1， 同时打印出promise1的状态是resolved；
- 执行同步代码2，同时打印出promise2的状态是pending；
- 宏任务执行完毕，查找微任务队列，发现promise1.then这个微任务且状态为resolved，执行它。

### 3
```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);
```
输出结果如下：
```js
1
2
4
timerStart
timerEnd
success
```
代码执行过程如下：

- 首先遇到Promise构造函数，会先执行里面的内容，打印1；
- 遇到定时器steTimeout，它是一个宏任务，放入宏任务队列；
- 继续向下执行，打印出2；
- 由于Promise的状态此时还是pending，所以promise.then先不执行；
- 继续执行下面的同步任务，打印出4；
- 此时微任务队列没有任务，继续执行下一轮宏任务，执行steTimeout；
- 首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerEnd；
- 执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。

### 4
```js
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');
```
输出结果如下：
```js
start
timer1
promise1
timer2
promise2
```
代码执行过程如下：

- 首先，Promise.resolve().then是一个微任务，加入微任务队列
- 执行timer1，它是一个宏任务，加入宏任务队列
- 继续执行下面的同步代码，打印出start
- 这样第一轮宏任务就执行完了，开始执行微任务Promise.resolve().then，打印出promise1
- 遇到timer2，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是timer1、timer2；
- 这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器timer1，打印timer1；
- 遇到Promise.resolve().then，它是一个微任务，加入微任务队列
- 开始执行微任务队列中的任务，打印promise2；
- 最后执行宏任务timer2定时器，打印出timer2；

### 5
```js
const promise = new Promise((resolve, reject) => {
  resolve('success1');
  reject('error');
  resolve('success2');
});
promise.then((res) => {
  console.log('then:', res);
}).catch((err) => {
  console.log('catch:', err);
})
```
输出结果如下：
```js
then：success1
```

这个题目考察的就是Promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。

### 6
```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
```
输出结果如下：
```js
1
Promise {<fulfilled>: undefined}
```

then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。

### 7
```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
```
输出结果如下：
```js
promise1 Promise {<pending>}
promise2 Promise {<pending>}

Uncaught (in promise) Error: error!!!
promise1 Promise {<fulfilled>: "success"}
promise2 Promise {<rejected>: Error: error!!}
```

### 8
```js
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });
```
输出结果如下：
```js
1
2
```
Promise是可以链式调用的，由于每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。

上面的输出结果之所以依次打印出1和2，是因为resolve(1)之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成resolve(2)，被最后的then打印输出2。

### 9
```
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
```
输出结果如下：
```js
1
2
```

### 10
```js
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
```
输出结果如下：
```js
Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```
这里其实是一个坑，.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。

### 29
```js
console.log(1);
    
setTimeout(() => {
  console.log(2);
  Promise.resolve().then(() => {
    console.log(3)
  });
});

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((data) => {
  console.log(data);
})

setTimeout(() => {
  console.log(6);
})

console.log(7);
```
输出结果如下：
```js
1
4
7 
5 
2
3
6
```

## 二、this

### 1
```js
function foo() {
  console.log( this.a );
}

function doFoo() {
  foo();
}

var obj = {
  a: 1,
  doFoo: doFoo
};

var a = 2; 
obj.doFoo()
```
输出结果如下：
```js
2
```
在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2

## 三、作用域&变量提升&闭包

## 四、原型&继承