(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{415:function(s,t,n){"use strict";n.r(t);var e=n(28),a=Object(e.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h3",{attrs:{id:"_1-对-react-hook-的理解-它的实现原理是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-对-react-hook-的理解-它的实现原理是什么"}},[s._v("#")]),s._v(" 1. 对 React Hook 的理解，它的实现原理是什么")]),s._v(" "),n("p",[s._v("React-Hooks 是 React 团队在 React 组件开发实践中，逐渐认知到的一个改进点，这背后其实涉及对"),n("strong",[s._v("类组件")]),s._v("和"),n("strong",[s._v("函数组件")]),s._v("两种组件形式的思考和侧重。")]),s._v(" "),n("p",[n("strong",[s._v("（1）类组件：")]),s._v(" 所谓类组件，就是基于 ES6 Class 这种写法，通过继承 React.Component 得来的 React 组件。以下是一个类组件：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('class DemoClass extends React.Component {\n  state = {\n    text: ""\n  };\n  componentDidMount() {\n    //...\n  }\n  changeText = (newText) => {\n    this.setState({\n      text: newText\n    });\n  };\n\n  render() {\n    return (\n      <div className="demoClass">\n        <p>{this.state.text}</p>\n        <button onClick={this.changeText}>修改</button>\n      </div>\n    );\n  }\n}\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])]),n("p",[s._v("可以看出，React 类组件内部预置了相当多的“现成的东西”等着我们去调度/定制，state 和生命周期就是这些“现成东西”中的典型。要想得到这些东西，难度也不大，只需要继承一个 React.Component 即可。")]),s._v(" "),n("p",[s._v("当然，这也是类组件的一个不便，它太繁杂了，对于解决许多问题来说，编写一个类组件实在是一个过于复杂的姿势。复杂的姿势必然带来高昂的理解成本，这也是我们所不想看到的。除此之外，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得"),n("strong",[s._v("类组件内部的逻辑难以实现拆分和复用。")])]),s._v(" "),n("p",[n("strong",[s._v("（2）函数组件")]),s._v("：函数组件就是以函数的形态存在的 React 组件。早期并没有 React-Hooks，函数组件内部无法定义和维护 state，因此它还有一个别名叫“无状态组件”。以下是一个函数组件：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('function DemoFunction(props) {\n  const { text } = props\n  return (\n    <div className="demoFunction">\n      <p>{`函数组件接收的内容：[${text}]`}</p>\n    </div>\n  );\n}\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("相比于类组件，函数组件肉眼可见的特质自然包括轻量、灵活、易于组织和维护、较低的学习成本等。")]),s._v(" "),n("p",[s._v("通过对比，从形态上可以对两种组件做区分，它们之间的区别如下：")]),s._v(" "),n("ul",[n("li",[s._v("类组件需要继承 class，函数组件不需要；")]),s._v(" "),n("li",[s._v("类组件可以访问生命周期方法，函数组件不能；")]),s._v(" "),n("li",[s._v("类组件中可以获取到实例化后的 this，并基于这个 this 做各种各样的事情，而函数组件不可以；")]),s._v(" "),n("li",[s._v("类组件中可以定义并维护 state（状态），而函数组件不可以；")])]),s._v(" "),n("p",[s._v("除此之外，还有一些其他的不同。通过上面的区别，我们不能说谁好谁坏，它们各有自己的优势。在 React-Hooks 出现之前，"),n("strong",[s._v("类组件的能力边界明显强于函数组件。")])]),s._v(" "),n("p",[s._v("实际上，类组件和函数组件之间，是面向对象和函数式编程这两套不同的设计思想之间的差异。而函数组件更加契合 React 框架的设计理念： "),n("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb5f01cfc83a48089e969f6443cb104b~tplv-k3u1fbpfcp-zoom-1.image",alt:"image.png"}}),s._v(" React 组件本身的定位就是函数，一个输入数据、输出 UI 的函数。作为开发者，我们编写的是声明式的代码，而 React 框架的主要工作，就是及时地把声明式的代码转换为命令式的 DOM 操作，把数据层面的描述映射到用户可见的 UI 变化中去。这就意味着从原则上来讲，React 的数据应该总是紧紧地和渲染绑定在一起的，而类组件做不到这一点。"),n("strong",[s._v("函数组件就真正地将数据和渲染绑定到了一起。函数组件是一个更加匹配其设计理念、也更有利于逻辑拆分与重用的组件表达形式。")])]),s._v(" "),n("p",[s._v("为了能让开发者更好的的去编写函数式组件。于是，React-Hooks 便应运而生。")]),s._v(" "),n("p",[s._v("React-Hooks 是一套能够使函数组件更强大、更灵活的“钩子”。")]),s._v(" "),n("p",[s._v("函数组件比起类组件少了很多东西，比如生命周期、对 state 的管理等。这就给函数组件的使用带来了非常多的局限性，导致我们并不能使用函数这种形式，写出一个真正的全功能的组件。而React-Hooks 的出现，就是为了帮助函数组件补齐这些（相对于类组件来说）缺失的能力。")]),s._v(" "),n("p",[s._v("如果说函数组件是一台轻巧的快艇，那么 React-Hooks 就是一个内容丰富的零部件箱。“重装战舰”所预置的那些设备，这个箱子里基本全都有，同时它还不强制你全都要，而是允许你自由地选择和使用你需要的那些能力，然后将这些能力以 Hook（钩子）的形式“钩”进你的组件里，从而定制出一个最适合你的“专属战舰”。")]),s._v(" "),n("h3",{attrs:{id:"_2-为什么-usestate-要使用数组而不是对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么-usestate-要使用数组而不是对象"}},[s._v("#")]),s._v(" 2. 为什么 useState 要使用数组而不是对象")]),s._v(" "),n("p",[s._v("useState 的用法：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const [count, setCount] = useState(0)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("可以看到 useState 返回的是一个数组，那么为什么是返回数组而不是返回对象呢？")]),s._v(" "),n("p",[s._v("这里用到了解构赋值，所以先来看一下ES6 的解构赋值：")]),s._v(" "),n("h5",{attrs:{id:"数组的解构赋值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组的解构赋值"}},[s._v("#")]),s._v(" 数组的解构赋值")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const foo = [1, 2, 3];\nconst [one, two, three] = foo;\nconsole.log(one);\t// 1\nconsole.log(two);\t// 2\nconsole.log(three);\t// 3\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("h5",{attrs:{id:"对象的解构赋值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象的解构赋值"}},[s._v("#")]),s._v(" 对象的解构赋值")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('const user = {\n  id: 888,\n  name: "xiaoxin"\n};\nconst { id, name } = user;\nconsole.log(id);\t// 888\nconsole.log(name);\t// "xiaoxin"\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("p",[s._v("看完这两个例子，答案应该就出来了：")]),s._v(" "),n("ul",[n("li",[s._v("如果 useState 返回的是数组，那么使用者可以对数组中的元素命名，代码看起来也比较干净")]),s._v(" "),n("li",[s._v("如果 useState 返回的是对象，在解构对象的时候必须要和 useState 内部实现返回的对象同名，想要使用多次的话，必须得设置别名才能使用返回值")])]),s._v(" "),n("p",[s._v("下面来看看如果 useState 返回对象的情况：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// 第一次使用\nconst { state, setState } = useState(false);\n// 第二次使用\nconst { state: counter, setState: setCounter } = useState(0) \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("p",[s._v("这里可以看到，返回对象的使用方式还是挺麻烦的，更何况实际项目中会使用的更频繁。 "),n("strong",[s._v("总结："),n("strong",[s._v("useState 返回的是 array 而不是 object 的原因就是为了")]),s._v("降低使用的复杂度")]),s._v("，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。")]),s._v(" "),n("h3",{attrs:{id:"_3-react-hooks-解决了哪些问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-react-hooks-解决了哪些问题"}},[s._v("#")]),s._v(" 3. React Hooks 解决了哪些问题？")]),s._v(" "),n("p",[s._v("React Hooks 主要解决了以下问题：")]),s._v(" "),n("p",[n("strong",[s._v("（1）在组件之间复用状态逻辑很难")])]),s._v(" "),n("p",[s._v("React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。")]),s._v(" "),n("p",[s._v("可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。")]),s._v(" "),n("p",[n("strong",[s._v("（2）复杂组件变得难以理解")])]),s._v(" "),n("p",[s._v("在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。")]),s._v(" "),n("p",[s._v("在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。")]),s._v(" "),n("p",[s._v("为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。")]),s._v(" "),n("p",[n("strong",[s._v("（3）难以理解的 class")])]),s._v(" "),n("p",[s._v("除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。")]),s._v(" "),n("p",[s._v("为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术")]),s._v(" "),n("h3",{attrs:{id:"_4-react-hook-的使用限制有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-hook-的使用限制有哪些"}},[s._v("#")]),s._v(" 4. React Hook 的使用限制有哪些？")]),s._v(" "),n("p",[s._v("React Hooks 的限制主要有两条：")]),s._v(" "),n("ul",[n("li",[s._v("不要在循环、条件或嵌套函数中调用 Hook；")]),s._v(" "),n("li",[s._v("在 React 的函数组件中调用 Hook。")])]),s._v(" "),n("p",[s._v("那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。")]),s._v(" "),n("ul",[n("li",[s._v("组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。")]),s._v(" "),n("li",[s._v("复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。")]),s._v(" "),n("li",[s._v("人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。")])]),s._v(" "),n("p",[s._v("这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks "),n("strong",[s._v("基于函数组件")]),s._v("开始设计。然而第三个问题决定了 Hooks 只支持函数组件。")]),s._v(" "),n("p",[s._v("那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。")]),s._v(" "),n("p",[s._v("这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。")]),s._v(" "),n("h3",{attrs:{id:"_5-useeffect-与-uselayouteffect-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-useeffect-与-uselayouteffect-的区别"}},[s._v("#")]),s._v(" 5. useEffect 与 useLayoutEffect 的区别")]),s._v(" "),n("p",[n("strong",[s._v("（1）共同点")])]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("运用效果：")]),s._v(" useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。")]),s._v(" "),n("li",[n("strong",[s._v("使用方式：")]),s._v(" useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。")])]),s._v(" "),n("p",[n("strong",[s._v("（2）不同点")])]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("使用场景：")]),s._v(" useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。")]),s._v(" "),n("li",[n("strong",[s._v("使用效果：")]),s._v(" useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。"),n("strong",[s._v("useLayoutEffect总是比useEffect先执行。")])])]),s._v(" "),n("p",[s._v("在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。")]),s._v(" "),n("h3",{attrs:{id:"_6-react-hooks在平时开发中需要注意的问题和原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-react-hooks在平时开发中需要注意的问题和原因"}},[s._v("#")]),s._v(" 6. React Hooks在平时开发中需要注意的问题和原因")]),s._v(" "),n("p",[s._v("（1）"),n("strong",[s._v("不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook")])]),s._v(" "),n("p",[s._v("这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。")]),s._v(" "),n("p",[n("strong",[s._v("（2）使用useState时候，使用push，pop，splice等直接更改数组对象的坑")])]),s._v(" "),n("p",[s._v("使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function Indicatorfilter() {\n  let [num,setNums] = useState([0,1,2,3])\n  const test = () => {\n    // 这里坑是直接采用push去更新num\n    // setNums(num)是无法更新num的\n    // 必须使用num = [...num ,1]\n    num.push(1)\n    // num = [...num ,1]\n    setNums(num)\n  }\nreturn (\n    <div className='filter'>\n      <div onClick={test}>测试</div>\n        <div>\n          {num.map((item,index) => (\n              <div key={index}>{item}</div>\n          ))}\n      </div>\n    </div>\n  )\n}\n\nclass Indicatorfilter extends React.Component<any,any>{\n  constructor(props:any){\n      super(props)\n      this.state = {\n          nums:[1,2,3]\n      }\n      this.test = this.test.bind(this)\n  }\n\n  test(){\n      // class采用同样的方式是没有问题的\n      this.state.nums.push(1)\n      this.setState({\n          nums: this.state.nums\n      })\n  }\n\n  render(){\n      let {nums} = this.state\n      return(\n          <div>\n              <div onClick={this.test}>测试</div>\n                  <div>\n                      {nums.map((item:any,index:number) => (\n                          <div key={index}>{item}</div>\n                      ))}\n                  </div>\n          </div>\n\n      )\n  }\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br"),n("span",{staticClass:"line-number"},[s._v("39")]),n("br"),n("span",{staticClass:"line-number"},[s._v("40")]),n("br"),n("span",{staticClass:"line-number"},[s._v("41")]),n("br"),n("span",{staticClass:"line-number"},[s._v("42")]),n("br"),n("span",{staticClass:"line-number"},[s._v("43")]),n("br"),n("span",{staticClass:"line-number"},[s._v("44")]),n("br"),n("span",{staticClass:"line-number"},[s._v("45")]),n("br"),n("span",{staticClass:"line-number"},[s._v("46")]),n("br"),n("span",{staticClass:"line-number"},[s._v("47")]),n("br"),n("span",{staticClass:"line-number"},[s._v("48")]),n("br"),n("span",{staticClass:"line-number"},[s._v("49")]),n("br"),n("span",{staticClass:"line-number"},[s._v("50")]),n("br"),n("span",{staticClass:"line-number"},[s._v("51")]),n("br"),n("span",{staticClass:"line-number"},[s._v("52")]),n("br"),n("span",{staticClass:"line-number"},[s._v("53")]),n("br"),n("span",{staticClass:"line-number"},[s._v("54")]),n("br")])]),n("p",[s._v("（3）"),n("strong",[s._v("useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect")])]),s._v(" "),n("p",[s._v("TableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const TableDeail = ({\n    columns,\n}:TableData) => {\n    const [tabColumn, setTabColumn] = useState(columns) \n}\n\n// 正确的做法是通过useEffect改变这个值\nconst TableDeail = ({\n    columns,\n}:TableData) => {\n    const [tabColumn, setTabColumn] = useState(columns) \n    useEffect(() =>{setTabColumn(columns)},[columns])\n}\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br")])]),n("p",[n("strong",[s._v("（4）善用useCallback")])]),s._v(" "),n("p",[s._v("父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。")]),s._v(" "),n("p",[n("strong",[s._v("（5）不要滥用useContext")])]),s._v(" "),n("p",[s._v("可以使用基于 useContext 封装的状态管理工具。")]),s._v(" "),n("h3",{attrs:{id:"_7-react-hooks-和生命周期的关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-react-hooks-和生命周期的关系"}},[s._v("#")]),s._v(" 7. React Hooks 和生命周期的关系？")]),s._v(" "),n("p",[n("strong",[s._v("函数组件")]),s._v(" 的本质是函数，没有 state 的概念的，因此"),n("strong",[s._v("不存在生命周期")]),s._v("一说，仅仅是一个 "),n("strong",[s._v("render 函数")]),s._v("而已。 但是引入 "),n("strong",[s._v("Hooks")]),s._v(" 之后就变得不同了，它能让组件在不使用 class 的情况下拥有 state，所以就有了生命周期的概念，所谓的生命周期其实就是 "),n("code",[s._v("useState")]),s._v("、 "),n("code",[s._v("useEffect()")]),s._v(" 和 "),n("code",[s._v("useLayoutEffect()")]),s._v(" 。")]),s._v(" "),n("p",[s._v("即："),n("strong",[s._v("Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的")]),s._v("。")]),s._v(" "),n("p",[s._v("下面是具体的 class 与 Hooks 的"),n("strong",[s._v("生命周期对应关系")]),s._v("：")]),s._v(" "),n("ul",[n("li",[n("code",[s._v("constructor")]),s._v("：函数组件不需要构造函数，可以通过调用 "),n("code",[s._v("**useState 来初始化 state**")]),s._v("。如果计算的代价比较昂贵，也可以传一个函数给 "),n("code",[s._v("useState")]),s._v("。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const [num, UpdateNum] = useState(0)\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("ul",[n("li",[n("code",[s._v("getDerivedStateFromProps")]),s._v("：一般情况下，我们不需要使用它，可以在"),n("strong",[s._v("渲染过程中更新 state")]),s._v("，以达到实现 "),n("code",[s._v("getDerivedStateFromProps")]),s._v(" 的目的。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("function ScrollView({row}) {\n  let [isScrollingDown, setIsScrollingDown] = useState(false);\n  let [prevRow, setPrevRow] = useState(null);\n  if (row !== prevRow) {\n    // Row 自上次渲染以来发生过改变。更新 isScrollingDown。\n    setIsScrollingDown(prevRow !== null && row > prevRow);\n    setPrevRow(row);\n  }\n  return `Scrolling down: ${isScrollingDown}`;\n}\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("React 会立即退出第一次渲染并用更新后的 state 重新运行组件以避免耗费太多性能。")]),s._v(" "),n("ul",[n("li",[n("code",[s._v("shouldComponentUpdate")]),s._v("：可以用 "),n("code",[s._v("**React.memo**")]),s._v(" 包裹一个组件来对它的 "),n("code",[s._v("props")]),s._v(" 进行浅比较")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const Button = React.memo((props) => {  // 具体的组件});\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("p",[s._v("注意："),n("code",[s._v("**React.memo 等效于 **``**PureComponent**")]),s._v("，它只浅比较 props。这里也可以使用 "),n("code",[s._v("useMemo")]),s._v(" 优化每一个节点。")]),s._v(" "),n("ul",[n("li",[n("code",[s._v("render")]),s._v("：这是函数组件体本身。")]),s._v(" "),n("li",[n("code",[s._v("componentDidMount")]),s._v(", "),n("code",[s._v("componentDidUpdate")]),s._v("： "),n("code",[s._v("useLayoutEffect")]),s._v(" 与它们两的调用阶段是一样的。但是，我们推荐你"),n("strong",[s._v("一开始先用 useEffect")]),s._v("，只有当它出问题的时候再尝试使用 "),n("code",[s._v("useLayoutEffect")]),s._v("。"),n("code",[s._v("useEffect")]),s._v(" 可以表达所有这些的组合。")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// componentDidMount\nuseEffect(()=>{\n  // 需要在 componentDidMount 执行的内容\n}, [])\nuseEffect(() => { \n  // 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容\n  document.title = `You clicked ${count} times`; \n  return () => {\n    // 需要在 count 更改时 componentDidUpdate（先于 document.title = ... 执行，遵守先清理后更新）\n    // 以及 componentWillUnmount 执行的内容       \n  } // 当函数中 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关\n}, [count]); // 仅在 count 更改时更新\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("p",[n("strong",[s._v("请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 ，因此会使得额外操作很方便")])]),s._v(" "),n("ul",[n("li",[n("code",[s._v("componentWillUnmount")]),s._v("：相当于 "),n("code",[s._v("useEffect")]),s._v("里面返回的 "),n("code",[s._v("cleanup")]),s._v(" 函数")])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("// componentDidMount/componentWillUnmount\nuseEffect(()=>{\n  // 需要在 componentDidMount 执行的内容\n  return function cleanup() {\n    // 需要在 componentWillUnmount 执行的内容      \n  }\n}, [])\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])]),n("ul",[n("li",[n("code",[s._v("componentDidCatch")]),s._v(" and "),n("code",[s._v("getDerivedStateFromError")]),s._v("：目前"),n("strong",[s._v("还没有")]),s._v("这些方法的 Hook 等价写法，但很快会加上。")])]),s._v(" "),n("table",[n("thead",[n("tr",[n("th",[n("strong",[s._v("class 组件")])]),s._v(" "),n("th",[n("strong",[s._v("Hooks 组件")])])])]),s._v(" "),n("tbody",[n("tr",[n("td",[s._v("constructor")]),s._v(" "),n("td",[s._v("useState")])]),s._v(" "),n("tr",[n("td",[s._v("getDerivedStateFromProps")]),s._v(" "),n("td",[s._v("useState 里面 update 函数")])]),s._v(" "),n("tr",[n("td",[s._v("shouldComponentUpdate")]),s._v(" "),n("td",[s._v("useMemo")])]),s._v(" "),n("tr",[n("td",[s._v("render")]),s._v(" "),n("td",[s._v("函数本身")])]),s._v(" "),n("tr",[n("td",[s._v("componentDidMount")]),s._v(" "),n("td",[s._v("useEffect")])]),s._v(" "),n("tr",[n("td",[s._v("componentDidUpdate")]),s._v(" "),n("td",[s._v("useEffect")])]),s._v(" "),n("tr",[n("td",[s._v("componentWillUnmount")]),s._v(" "),n("td",[s._v("useEffect 里面返回的函数")])]),s._v(" "),n("tr",[n("td",[s._v("componentDidCatch")]),s._v(" "),n("td",[s._v("无")])]),s._v(" "),n("tr",[n("td",[s._v("getDerivedStateFromError")]),s._v(" "),n("td",[s._v("无")])])])])])}),[],!1,null,null,null);t.default=a.exports}}]);