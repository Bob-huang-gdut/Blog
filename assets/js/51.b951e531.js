(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{427:function(s,e,a){"use strict";a.r(e);var n=a(28),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"_1-vue-router-的懒加载如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue-router-的懒加载如何实现"}},[s._v("#")]),s._v(" 1. Vue-Router 的懒加载如何实现")]),s._v(" "),a("p",[s._v("非懒加载：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("import List from '@/components/list.vue'\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("（1）方案一(常用)：使用箭头函数+import动态加载")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const List = () => import('@/components/list.vue')\nconst router = new VueRouter({\n  routes: [\n    { path: '/list', component: List }\n  ]\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("（2）方案二：使用箭头函数+require动态加载")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const router = new Router({\n  routes: [\n   {\n     path: '/list',\n     component: resolve => require(['@/components/list'], resolve)\n   }\n  ]\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// r就是resolve\nconst List = r => require.ensure([], () => r(require('@/components/list')), 'list');\n// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 \nconst router = new Router({\n  routes: [\n  {\n    path: '/list',\n    component: List,\n    name: 'list'\n  }\n ]\n}))\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("h3",{attrs:{id:"_2-路由的hash和history模式的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-路由的hash和history模式的区别"}},[s._v("#")]),s._v(" 2. 路由的hash和history模式的区别")]),s._v(" "),a("p",[s._v("Vue-Router有两种模式："),a("strong",[s._v("hash模式")]),s._v("和"),a("strong",[s._v("history模式")]),s._v("。默认的路由模式是hash模式。")]),s._v(" "),a("h4",{attrs:{id:"_1-hash模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash模式"}},[s._v("#")]),s._v(" 1. hash模式")]),s._v(" "),a("p",[a("strong",[s._v("简介：")]),s._v(" hash模式是开发中默认的模式，它的URL带着一个#，例如："),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fwww.abc.com%2F%23%2Fvue",title:"http://www.abc.com/#/vue",target:"_blank",rel:"noopener noreferrer"}},[s._v("www.abc.com/#/vue"),a("OutboundLink")],1),s._v("，它的hash值就是"),a("code",[s._v("#/vue")]),s._v("。")]),s._v(" "),a("p",[a("strong",[s._v("特点")]),s._v("：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。")]),s._v(" "),a("p",[a("strong",[s._v("原理：")]),s._v(" hash模式的主要原理就是"),a("strong",[s._v("onhashchange()事件")]),s._v("：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("window.onhashchange = function(event){\n\tconsole.log(event.oldURL, event.newURL);\n\tlet hash = location.hash.slice(1);\n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。")]),s._v(" "),a("h4",{attrs:{id:"_2-history模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-history模式"}},[s._v("#")]),s._v(" 2. history模式")]),s._v(" "),a("p",[a("strong",[s._v("简介：")]),s._v(" history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。 "),a("strong",[s._v("特点：")]),s._v(" 当使用history模式时，URL就像这样："),a("a",{attrs:{href:"https://link.juejin.cn?target=http%3A%2F%2Fabc.com%2Fuser%2Fid",title:"http://abc.com/user/id",target:"_blank",rel:"noopener noreferrer"}},[s._v("abc.com/user/id"),a("OutboundLink")],1),s._v("。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。 "),a("strong",[s._v("API：")]),s._v(" history api可以分为两大部分，切换历史状态和修改历史状态：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("修改历史状态")]),s._v("：包括了 HTML5 History Interface 中新增的 "),a("code",[s._v("pushState()")]),s._v(" 和 "),a("code",[s._v("replaceState()")]),s._v(" 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。")]),s._v(" "),a("li",[a("strong",[s._v("切换历史状态：")]),s._v(" 包括"),a("code",[s._v("forward()")]),s._v("、"),a("code",[s._v("back()")]),s._v("、"),a("code",[s._v("go()")]),s._v("三个方法，对应浏览器的前进，后退，跳转操作。")])]),s._v(" "),a("p",[s._v("虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。")]),s._v(" "),a("p",[s._v("如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h4",{attrs:{id:"_3-两种模式对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-两种模式对比"}},[s._v("#")]),s._v(" 3. 两种模式对比")]),s._v(" "),a("p",[s._v("调用 history.pushState() 相比于直接修改 hash，存在以下优势:")]),s._v(" "),a("ul",[a("li",[s._v("pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；")]),s._v(" "),a("li",[s._v("pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；")]),s._v(" "),a("li",[s._v("pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；")]),s._v(" "),a("li",[s._v("pushState() 可额外设置 title 属性供后续使用。")]),s._v(" "),a("li",[s._v("hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。")])]),s._v(" "),a("p",[s._v("hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。")]),s._v(" "),a("h3",{attrs:{id:"_3-如何获取页面的hash变化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-如何获取页面的hash变化"}},[s._v("#")]),s._v(" 3. 如何获取页面的hash变化")]),s._v(" "),a("p",[a("strong",[s._v("（1）监听$route的变化")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 监听,当路由发生变化的时候执行\nwatch: {\n  $route: {\n    handler: function(val, oldVal){\n      console.log(val);\n    },\n    // 深度观察监听\n    deep: true\n  }\n},\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[a("strong",[s._v("（2）window.location.hash读取#值")]),s._v(" window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。")]),s._v(" "),a("h3",{attrs:{id:"_4-route-和-router-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-route-和-router-的区别"}},[s._v("#")]),s._v(" 4. "),a("code",[s._v("$route 和$router")]),s._v(" 的区别")]),s._v(" "),a("ul",[a("li",[s._v("$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数")]),s._v(" "),a("li",[s._v("$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])]),s._v(" "),a("h3",{attrs:{id:"_5-如何定义动态路由-如何获取传过来的动态参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何定义动态路由-如何获取传过来的动态参数"}},[s._v("#")]),s._v(" 5. 如何定义动态路由？如何获取传过来的动态参数？")]),s._v(" "),a("p",[a("strong",[s._v("（1）param方式")])]),s._v(" "),a("ul",[a("li",[s._v("配置路由格式："),a("code",[s._v("/router/:id")])]),s._v(" "),a("li",[s._v("传递的方式：在path后面跟上对应的值")]),s._v(" "),a("li",[s._v("传递后形成的路径："),a("code",[s._v("/router/123")])])]),s._v(" "),a("p",[s._v("1）路由定义")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("//在APP.vue中\n<router-link :to=\"'/user/'+userId\" replace>用户</router-link>    \n\n//在index.js\n{\n   path: '/user/:userid',\n   component: User,\n},\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("2）路由跳转")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 方法1：\n<router-link :to=\"{ name: 'users', params: { uname: wade }}\">按钮</router-link\n\n// 方法2：\nthis.$router.push({name:'users',params:{uname:wade}})\n\n// 方法3：\nthis.$router.push('/user/' + wade)\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("p",[s._v("3）参数获取 通过 "),a("code",[s._v("$route.params.userid")]),s._v(" 获取传递的值")]),s._v(" "),a("p",[a("strong",[s._v("（2）query方式")])]),s._v(" "),a("ul",[a("li",[s._v("配置路由格式："),a("code",[s._v("/router")]),s._v("，也就是普通配置")]),s._v(" "),a("li",[s._v("传递的方式：对象中使用query的key作为传递方式")]),s._v(" "),a("li",[s._v("传递后形成的路径："),a("code",[s._v("/route?id=123")])])]),s._v(" "),a("p",[s._v("1）路由定义")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('//方式1：直接在router-link 标签上以对象的形式\n<router-link :to="{path:\'/profile\',query:{name:\'why\',age:28,height:188}}">档案</router-link>\n\n// 方式2：写成按钮以点击事件形式\n<button @click=\'profileClick\'>我的</button>    \n\nprofileClick(){\n  this.$router.push({\n    path: "/profile",\n    query: {\n        name: "kobi",\n        age: "28",\n        height: 198\n    }\n  });\n}\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("p",[s._v("2）跳转方法")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("// 方法1：\n<router-link :to=\"{ name: 'users', query: { uname: james }}\">按钮</router-link>\n\n// 方法2：\nthis.$router.push({ name: 'users', query:{ uname:james }})\n\n// 方法3：\n<router-link :to=\"{ path: '/user', query: { uname:james }}\">按钮</router-link>\n\n// 方法4：\nthis.$router.push({ path: '/user', query:{ uname:james }})\n\n// 方法5：\nthis.$router.push('/user?uname=' + jsmes)\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("3）获取参数")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("通过$route.query 获取传递的值\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h3",{attrs:{id:"_6-vue-router-路由钩子在生命周期的体现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-router-路由钩子在生命周期的体现"}},[s._v("#")]),s._v(" 6. Vue-router 路由钩子在生命周期的体现")]),s._v(" "),a("p",[s._v("一、Vue-Router导航守卫")]),s._v(" "),a("p",[s._v("有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。 为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的")]),s._v(" "),a("ol",[a("li",[s._v("全局路由钩子")])]),s._v(" "),a("p",[s._v("vue-router全局有三个路由钩子;")]),s._v(" "),a("ul",[a("li",[s._v("router.beforeEach 全局前置守卫 进入路由之前")]),s._v(" "),a("li",[s._v("router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用")]),s._v(" "),a("li",[s._v("router.afterEach 全局后置钩子 进入路由之后")])]),s._v(" "),a("p",[s._v("具体使用∶")]),s._v(" "),a("ul",[a("li",[s._v("beforeEach（判断是否登录了，没登录就跳转到登录页）")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("router.beforeEach((to, from, next) => {  \n    let ifInfo = Vue.prototype.$common.getSession('userData');  // 判断是否登录的存储信息\n    if (!ifInfo) { \n        // sessionStorage里没有储存user信息    \n        if (to.path == '/') { \n            //如果是登录页面路径，就直接next()      \n            next();    \n        } else { \n            //不然就跳转到登录      \n            Message.warning(\"请重新登录！\");     \n            window.location.href = Vue.prototype.$loginUrl;    \n        }  \n    } else {    \n        return next();  \n    }\n})\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br")])]),a("ul",[a("li",[s._v("afterEach （跳转之后滚动条回到顶部）")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("router.afterEach((to, from) => {  \n    // 跳转之后滚动条回到顶部  \n    window.scrollTo(0,0);\n});\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("ol",{attrs:{start:"2"}},[a("li",[s._v("单个路由独享钩子")])]),s._v(" "),a("p",[a("strong",[s._v("beforeEnter")]),s._v(" 如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("export default [    \n    {        \n        path: '/',        \n        name: 'login',        \n        component: login,        \n        beforeEnter: (to, from, next) => {          \n            console.log('即将进入登录页面')          \n            next()        \n        }    \n    }\n]\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[s._v("组件内钩子")])]),s._v(" "),a("p",[s._v("beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave")]),s._v(" "),a("p",[s._v("这三个钩子都有三个参数∶to、from、next")]),s._v(" "),a("ul",[a("li",[s._v("beforeRouteEnter∶ 进入组件前触发")]),s._v(" "),a("li",[s._v("beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用")]),s._v(" "),a("li",[s._v("beforeRouteLeave∶ 离开组件被调用")])]),s._v(" "),a("p",[s._v("注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("beforeRouteEnter(to, from, next) {      \n    next(target => {        \n        if (from.path == '/classProcess') {          \n            target.isFromProcess = true        \n        }      \n    })    \n}\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("二、Vue路由钩子在生命周期函数的体现")]),s._v(" "),a("ol",[a("li",[s._v("完整的路由导航解析流程（不包括其他生命周期）")])]),s._v(" "),a("ul",[a("li",[s._v("触发进入其他路由。")]),s._v(" "),a("li",[s._v("调用要离开路由的组件守卫beforeRouteLeave")]),s._v(" "),a("li",[s._v("调用局前置守卫∶ beforeEach")]),s._v(" "),a("li",[s._v("在重用的组件里调用 beforeRouteUpdate")]),s._v(" "),a("li",[s._v("调用路由独享守卫 beforeEnter。")]),s._v(" "),a("li",[s._v("解析异步路由组件。")]),s._v(" "),a("li",[s._v("在将要进入的路由组件中调用 beforeRouteEnter")]),s._v(" "),a("li",[s._v("调用全局解析守卫 beforeResolve")]),s._v(" "),a("li",[s._v("导航被确认。")]),s._v(" "),a("li",[s._v("调用全局后置钩子的 afterEach 钩子。")]),s._v(" "),a("li",[s._v("触发DOM更新（mounted）。")]),s._v(" "),a("li",[s._v("执行beforeRouteEnter 守卫中传给 next 的回调函数")])]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("触发钩子的完整顺序")])]),s._v(" "),a("p",[s._v("路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶")]),s._v(" "),a("ul",[a("li",[s._v("beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。")]),s._v(" "),a("li",[s._v("beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。")]),s._v(" "),a("li",[s._v("beforeEnter：路由独享守卫")]),s._v(" "),a("li",[s._v("beforeRouteEnter：路由组件的组件进入路由前钩子。")]),s._v(" "),a("li",[s._v("beforeResolve：路由全局解析守卫")]),s._v(" "),a("li",[s._v("afterEach：路由全局后置钩子")]),s._v(" "),a("li",[s._v("beforeCreate：组件生命周期，不能访问tAis。")]),s._v(" "),a("li",[s._v("created;组件生命周期，可以访问tAis，不能访问dom。")]),s._v(" "),a("li",[s._v("beforeMount：组件生命周期")]),s._v(" "),a("li",[s._v("deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。")]),s._v(" "),a("li",[s._v("mounted：访问/操作dom。")]),s._v(" "),a("li",[s._v("activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。")]),s._v(" "),a("li",[s._v("执行beforeRouteEnter回调函数next。")])]),s._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[s._v("导航行为被触发到导航完成的整个过程")])]),s._v(" "),a("ul",[a("li",[s._v("导航行为被触发，此时导航未被确认。")]),s._v(" "),a("li",[s._v("在失活的组件里调用离开守卫 beforeRouteLeave。")]),s._v(" "),a("li",[s._v("调用全局的 beforeEach守卫。")]),s._v(" "),a("li",[s._v("在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。")]),s._v(" "),a("li",[s._v("在路由配置里调用 beforeEnteY。")]),s._v(" "),a("li",[s._v("解析异步路由组件（如果有）。")]),s._v(" "),a("li",[s._v("在被激活的组件里调用 beforeRouteEnter。")]),s._v(" "),a("li",[s._v("调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。")]),s._v(" "),a("li",[s._v("导航被确认。")]),s._v(" "),a("li",[s._v("调用全局的 afterEach 钩子。")]),s._v(" "),a("li",[s._v("非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted")]),s._v(" "),a("li",[s._v("触发 DOM 更新。")]),s._v(" "),a("li",[s._v("用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。")]),s._v(" "),a("li",[s._v("导航完成")])]),s._v(" "),a("h3",{attrs:{id:"_7-vue-router跳转和location-href有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-router跳转和location-href有什么区别"}},[s._v("#")]),s._v(" 7. Vue-router跳转和location.href有什么区别")]),s._v(" "),a("ul",[a("li",[s._v("使用 "),a("code",[s._v("location.href= /url")]),s._v("来跳转，简单方便，但是刷新了页面；")]),s._v(" "),a("li",[s._v("使用 "),a("code",[s._v("history.pushState( /url )")]),s._v(" ，无刷新页面，静态跳转；")]),s._v(" "),a("li",[s._v("引进 router ，然后使用 "),a("code",[s._v("router.push( /url )")]),s._v(" 来跳转，使用了 "),a("code",[s._v("diff")]),s._v(" 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 "),a("code",[s._v("history.pushState()")]),s._v(" 没什么差别的，因为vue-router就是用了 "),a("code",[s._v("history.pushState()")]),s._v(" ，尤其是在history模式下。")])]),s._v(" "),a("h3",{attrs:{id:"_8-params和query的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-params和query的区别"}},[s._v("#")]),s._v(" 8. params和query的区别")]),s._v(" "),a("p",[a("strong",[s._v("用法")]),s._v("：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 "),a("code",[s._v("this.$route.query.name")]),s._v(" 和 "),a("code",[s._v("this.$route.params.name")]),s._v(" 。")]),s._v(" "),a("p",[a("strong",[s._v("url地址显示")]),s._v("：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示")]),s._v(" "),a("p",[a("strong",[s._v("注意")]),s._v("：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。")]),s._v(" "),a("h3",{attrs:{id:"_9-vue-router-导航守卫有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-router-导航守卫有哪些"}},[s._v("#")]),s._v(" 9. Vue-router 导航守卫有哪些")]),s._v(" "),a("ul",[a("li",[s._v("全局前置/钩子：beforeEach、beforeResolve、afterEach")]),s._v(" "),a("li",[s._v("路由独享的守卫：beforeEnter")]),s._v(" "),a("li",[s._v("组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave")])]),s._v(" "),a("h3",{attrs:{id:"_10-对前端路由的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-对前端路由的理解"}},[s._v("#")]),s._v(" 10. 对前端路由的理解")]),s._v(" "),a("p",[s._v("在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。")]),s._v(" "),a("p",[s._v("后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 "),a("strong",[s._v("SPA（单页面应用")]),s._v("）。")]),s._v(" "),a("p",[s._v("SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：")]),s._v(" "),a("ul",[a("li",[s._v("SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。")]),s._v(" "),a("li",[s._v("由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息")])]),s._v(" "),a("p",[s._v("为了解决这个问题，前端路由出现了。")]),s._v(" "),a("p",[s._v("前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。")]),s._v(" "),a("p",[s._v("那么如何实现这个目的呢？首先要解决两个问题：")]),s._v(" "),a("ul",[a("li",[s._v("当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。")]),s._v(" "),a("li",[s._v("单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？")])]),s._v(" "),a("p",[s._v("从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：")]),s._v(" "),a("ul",[a("li",[s._v("拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。")]),s._v(" "),a("li",[s._v("感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。")])])])}),[],!1,null,null,null);e.default=t.exports}}]);