(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{379:function(e,t,s){"use strict";s.r(t);var r=s(46),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"js基础知识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js基础知识"}},[e._v("#")]),e._v(" js基础知识")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("🔥「2021」高频前端面试题汇总之JavaScript篇（下）\nhttps://juejin.cn/post/6941194115392634888")])]),e._v(" "),s("h2",{attrs:{id:"异步编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[e._v("#")]),e._v(" 异步编程")]),e._v(" "),s("p",[e._v("JavaScript中的异步机制可以分为以下几种：")]),e._v(" "),s("h3",{attrs:{id:"异步编程的实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程的实现方式"}},[e._v("#")]),e._v(" 异步编程的实现方式？")]),e._v(" "),s("ul",[s("li",[e._v("回调函数\n的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。")]),e._v(" "),s("li",[e._v("Promise\n的方式，使用 Promise 的方式可以将嵌套的回调函数作为"),s("strong",[e._v("链式调用")]),e._v("。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。")]),e._v(" "),s("li",[e._v("generator\n的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。")]),e._v(" "),s("li",[e._v("async 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。")])]),e._v(" "),s("h3",{attrs:{id:"对promise的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对promise的理解"}},[e._v("#")]),e._v(" 对Promise的理解")]),e._v(" "),s("p",[e._v("Promise是异步编程的一种解决方案，其出现主要解决回调的“地狱回调”问题，所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。Promise 是一个构造函数，接收一个函数"),s("code",[e._v("function(resolve, reject) {}")]),e._v("作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。")]),e._v(" "),s("p",[e._v("Promise的实例有三个状态:")]),e._v(" "),s("ul",[s("li",[e._v("Pending（进行中）")]),e._v(" "),s("li",[e._v("Resolved（已完成）")]),e._v(" "),s("li",[e._v("Rejected（已拒绝）\n两个过程：")]),e._v(" "),s("li",[e._v("pending -> fulfilled : Resolved（已完成）")]),e._v(" "),s("li",[e._v("pending -> rejected：Rejected（已拒绝）")])])])}),[],!1,null,null,null);t.default=a.exports}}]);