<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>黄思博 blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/images/logo.png">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="前端工程师,前端自学,高级前端工程师,中高级前端工程师,前端进阶知识,前端职业发展">
    
    <link rel="preload" href="/blog/assets/css/0.styles.63322341.css" as="style"><link rel="preload" href="/blog/assets/js/app.892c39d6.js" as="script"><link rel="preload" href="/blog/assets/js/2.312bc144.js" as="script"><link rel="preload" href="/blog/assets/js/66.751c0c8a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.a2d4c1a1.js"><link rel="prefetch" href="/blog/assets/js/11.75736306.js"><link rel="prefetch" href="/blog/assets/js/12.bfce1da5.js"><link rel="prefetch" href="/blog/assets/js/13.139c024c.js"><link rel="prefetch" href="/blog/assets/js/14.a6f9405d.js"><link rel="prefetch" href="/blog/assets/js/15.6c7b98d6.js"><link rel="prefetch" href="/blog/assets/js/16.2d2fea40.js"><link rel="prefetch" href="/blog/assets/js/17.6ffeba9b.js"><link rel="prefetch" href="/blog/assets/js/18.c4a3b299.js"><link rel="prefetch" href="/blog/assets/js/19.a9f19523.js"><link rel="prefetch" href="/blog/assets/js/20.53721a79.js"><link rel="prefetch" href="/blog/assets/js/21.834dbeef.js"><link rel="prefetch" href="/blog/assets/js/22.6342486f.js"><link rel="prefetch" href="/blog/assets/js/23.4bf27002.js"><link rel="prefetch" href="/blog/assets/js/24.f7f838f9.js"><link rel="prefetch" href="/blog/assets/js/25.2bd346fd.js"><link rel="prefetch" href="/blog/assets/js/26.decb663e.js"><link rel="prefetch" href="/blog/assets/js/27.36cac2ed.js"><link rel="prefetch" href="/blog/assets/js/28.643209af.js"><link rel="prefetch" href="/blog/assets/js/29.3e1ea5c9.js"><link rel="prefetch" href="/blog/assets/js/3.b2d4aa58.js"><link rel="prefetch" href="/blog/assets/js/30.1b6ac513.js"><link rel="prefetch" href="/blog/assets/js/31.b65e343c.js"><link rel="prefetch" href="/blog/assets/js/32.5183629d.js"><link rel="prefetch" href="/blog/assets/js/33.29b7c360.js"><link rel="prefetch" href="/blog/assets/js/34.c10e7e08.js"><link rel="prefetch" href="/blog/assets/js/35.39969a95.js"><link rel="prefetch" href="/blog/assets/js/36.e5347233.js"><link rel="prefetch" href="/blog/assets/js/37.d8b08806.js"><link rel="prefetch" href="/blog/assets/js/38.b80b22ad.js"><link rel="prefetch" href="/blog/assets/js/39.f1861715.js"><link rel="prefetch" href="/blog/assets/js/4.031d788a.js"><link rel="prefetch" href="/blog/assets/js/40.a41f5ce9.js"><link rel="prefetch" href="/blog/assets/js/41.1e808ae5.js"><link rel="prefetch" href="/blog/assets/js/42.03ae7a8d.js"><link rel="prefetch" href="/blog/assets/js/43.ad3034b8.js"><link rel="prefetch" href="/blog/assets/js/44.910af0c5.js"><link rel="prefetch" href="/blog/assets/js/45.8efaadf5.js"><link rel="prefetch" href="/blog/assets/js/46.df0fe0fa.js"><link rel="prefetch" href="/blog/assets/js/47.0eccc6b9.js"><link rel="prefetch" href="/blog/assets/js/48.c6cfd5ae.js"><link rel="prefetch" href="/blog/assets/js/49.9af22939.js"><link rel="prefetch" href="/blog/assets/js/5.f99d1604.js"><link rel="prefetch" href="/blog/assets/js/50.f471ea86.js"><link rel="prefetch" href="/blog/assets/js/51.3b6548c5.js"><link rel="prefetch" href="/blog/assets/js/52.dfebfa7f.js"><link rel="prefetch" href="/blog/assets/js/53.73f1fbb0.js"><link rel="prefetch" href="/blog/assets/js/54.ce42cb03.js"><link rel="prefetch" href="/blog/assets/js/55.1840a59a.js"><link rel="prefetch" href="/blog/assets/js/56.e7517d67.js"><link rel="prefetch" href="/blog/assets/js/57.1e7d8b92.js"><link rel="prefetch" href="/blog/assets/js/58.b402314b.js"><link rel="prefetch" href="/blog/assets/js/59.0cda0376.js"><link rel="prefetch" href="/blog/assets/js/6.185609d6.js"><link rel="prefetch" href="/blog/assets/js/60.62b85974.js"><link rel="prefetch" href="/blog/assets/js/61.c1a85c44.js"><link rel="prefetch" href="/blog/assets/js/62.dcdd9fe4.js"><link rel="prefetch" href="/blog/assets/js/63.e4b791fe.js"><link rel="prefetch" href="/blog/assets/js/64.f6861c2e.js"><link rel="prefetch" href="/blog/assets/js/65.2ab3a131.js"><link rel="prefetch" href="/blog/assets/js/67.d3d66fa1.js"><link rel="prefetch" href="/blog/assets/js/68.41cad479.js"><link rel="prefetch" href="/blog/assets/js/69.d6aba464.js"><link rel="prefetch" href="/blog/assets/js/7.492b4d85.js"><link rel="prefetch" href="/blog/assets/js/70.63aa90b9.js"><link rel="prefetch" href="/blog/assets/js/71.2399949d.js"><link rel="prefetch" href="/blog/assets/js/72.e9756d6a.js"><link rel="prefetch" href="/blog/assets/js/73.379a469c.js"><link rel="prefetch" href="/blog/assets/js/74.88d381d5.js"><link rel="prefetch" href="/blog/assets/js/75.5e6a236e.js"><link rel="prefetch" href="/blog/assets/js/76.a6d0788a.js"><link rel="prefetch" href="/blog/assets/js/77.3f0b4376.js"><link rel="prefetch" href="/blog/assets/js/78.7f20e698.js"><link rel="prefetch" href="/blog/assets/js/79.d7b43612.js"><link rel="prefetch" href="/blog/assets/js/8.75e87c72.js"><link rel="prefetch" href="/blog/assets/js/80.1505c7a2.js"><link rel="prefetch" href="/blog/assets/js/81.af76ceaf.js"><link rel="prefetch" href="/blog/assets/js/82.46c881b8.js"><link rel="prefetch" href="/blog/assets/js/83.0a7b27df.js"><link rel="prefetch" href="/blog/assets/js/84.73ca0907.js"><link rel="prefetch" href="/blog/assets/js/85.5b8095bc.js"><link rel="prefetch" href="/blog/assets/js/86.4d66e867.js"><link rel="prefetch" href="/blog/assets/js/87.1d044f71.js"><link rel="prefetch" href="/blog/assets/js/9.3dbbf6ba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.63322341.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/images/logo.png" alt="黄思博 blog" class="logo"> <span class="site-name can-hide">黄思博 blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><a href="/blog/pages/summary/" class="nav-link">
  个人总结
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><a href="/blog/pages/summary/" class="nav-link">
  个人总结
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/knowledgeBase/" aria-current="page" class="sidebar-link">知识库</a></li><li><a href="/blog/pages/knowledgeBase/html/" class="sidebar-link">html</a></li><li><a href="/blog/pages/knowledgeBase/nginx/" class="sidebar-link">nginx</a></li><li><a href="/blog/pages/knowledgeBase/node/" class="sidebar-link">node</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>移动端</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/knowledgeBase/移动端/1.html" class="active sidebar-link">各类移动端技术对比总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_1、跨平台技术简介" class="sidebar-link">1、跨平台技术简介</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_2、hybrid技术简介" class="sidebar-link">2、Hybrid技术简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_2-1-h5-原生混合开发" class="sidebar-link">2.1 H5+原生混合开发</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_2-2-混合开发技术点" class="sidebar-link">2.2 混合开发技术点</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_3、react-native、weex及快应用" class="sidebar-link">3、React Native、Weex及快应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_3-1-react-native" class="sidebar-link">3.1 React-Native</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_3-2-weex" class="sidebar-link">3.2 Weex</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#总结-2" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_4、-自绘制引擎" class="sidebar-link">4、 自绘制引擎</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_4-1-qt-mobile" class="sidebar-link">4.1 QT Mobile</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_4-2-flutter" class="sidebar-link">4.2 Flutter</a></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#_4-3-dart和javascript做一个对比" class="sidebar-link">4.3 Dart和JavaScript做一个对比</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/pages/knowledgeBase/移动端/1.html#总结-3" class="sidebar-link">总结</a></li></ul></li><li><a href="/blog/pages/knowledgeBase/移动端/react-native/1.html" class="sidebar-link">react-native</a></li><li><a href="/blog/pages/knowledgeBase/移动端/weex/1.html" class="sidebar-link">weex</a></li><li><a href="/blog/pages/knowledgeBase/移动端/flutter/1.html" class="sidebar-link">flutter</a></li><li><a href="/blog/pages/knowledgeBase/移动端/H5/1.html" class="sidebar-link">H5</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="sidebar-link">设计模式</a></li><li><a href="/blog/pages/knowledgeBase/web%E8%84%9A%E6%89%8B%E6%9E%B6/" class="sidebar-link">web脚手架</a></li><li><a href="/blog/pages/knowledgeBase/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" class="sidebar-link">数据可视化</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/typeScript/" class="sidebar-link">typeScript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/%E6%B5%8F%E8%A7%88%E5%99%A8/" class="sidebar-link">浏览器</a></li><li><a href="/blog/pages/knowledgeBase/network/" class="sidebar-link">计算机网络</a></li><li><a href="/blog/pages/knowledgeBase/%E9%AA%A8%E6%9E%B6%E5%B1%8F/" class="sidebar-link">骨架屏</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/" class="sidebar-link">移动端适配</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>手写代码</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/docker/" class="sidebar-link">docker</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>总结</p> <p>React Native渲染, JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：为JavaScript提供运行环境。
是JavaScript与原生应用之间通信的桥梁。React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。</p> <h2 id="_1、跨平台技术简介"><a href="#_1、跨平台技术简介" class="header-anchor">#</a> 1、跨平台技术简介</h2> <p>跨平台技术主要为三类：</p> <ul><li>H5+原生（<code>Cordova</code>、<code>Ionic</code>、<code>微信小程序</code>）</li> <li>JavaScript开发+原生渲染 （<code>React Native</code>、<code>Weex</code>、<code>快应用</code>）</li> <li>自绘UI+原生(<code>QT for mobile</code>、<code>Flutter</code>)</li></ul> <h2 id="_2、hybrid技术简介"><a href="#_2、hybrid技术简介" class="header-anchor">#</a> 2、Hybrid技术简介</h2> <h3 id="_2-1-h5-原生混合开发"><a href="#_2-1-h5-原生混合开发" class="header-anchor">#</a> 2.1 H5+原生混合开发</h3> <p>这类框架主要原理就是将APP的一部分需要动态变动的内容通过H5来实现，通过原生的网页加载控件WebView (<code>Android</code>)或<code>WKWebView</code>（iOS）来加载（以后若无特殊说明，我们用<code>WebView</code>来统一指代<code>android</code>和<code>iOS</code>中的网页加载控件）。这样以来，H5部分是可以随时改变而不用发版，动态化需求能满足；同时，由于h5代码只需要一次开发，就能同时在Android和iOS两个平台运行，这也可以减小开发成本，也就是说，H5部分功能越多，开发成本就越小。我们称这种h5+原生的开发模式为混合开发 ，采用混合模式开发的APP我们称之为<code>混合应用</code>或<code>Hybrid APP</code>，如果一个应用的大多数功能都是<code>H5</code>实现的话，我们称其为<code>Web APP</code> 。</p> <p>目前混合开发框架的典型代表有：<code>Cordova</code>、<code>Ionic</code> 和<code>微信小程序</code>，值得一提的是<code>微信小程序</code>目前是在<code>webview</code>中渲染的，并非原生渲染，但将来有可能会采用原生渲染。</p> <h3 id="_2-2-混合开发技术点"><a href="#_2-2-混合开发技术点" class="header-anchor">#</a> 2.2 混合开发技术点</h3> <p>如之前所述，原生开发可以访问平台所有功能，而混合开发中，H5代码是运行在WebView中，而WebView实质上就是一个浏览器内核，其JavaScript依然运行在一个权限受限的沙箱中，所以对于大多数系统能力都没有访问权限，如无法访问文件系统、不能使用蓝牙等。所以，对于H5不能实现的功能，都需要原生去做。而混合框架一般都会在原生代码中预先实现一些访问系统能力的API， 然后暴露给WebView以供JavaScript调用，这样一来，WebView就成为了JavaScript与原生API之间通信的桥梁，主要负责JavaScript与原生之间传递调用消息，而消息的传递必须遵守一个标准的协议，它规定了消息的格式与含义，我们把依赖于WebView的用于在JavaScript与原生之间通信并实现了某种消息传输协议的工具称之为WebView JavaScript Bridge, 简称 JsBridge，它也是混合开发框架的核心。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>混合应用的优点是动态内容是H5，web技术栈，社区及资源丰富，缺点是性能不好，对于复杂用户界面或动画，WebView不堪重任。</p> <h2 id="_3、react-native、weex及快应用"><a href="#_3、react-native、weex及快应用" class="header-anchor">#</a> 3、React Native、Weex及快应用</h2> <h3 id="_3-1-react-native"><a href="#_3-1-react-native" class="header-anchor">#</a> 3.1 React-Native</h3> <p>React Native (简称RN)是Facebook于2015年4月开源的跨平台移动应用开发框架，是Facebook早先开源的JS框架 。</p> <h4 id="_3-1-1-dom树与控件树"><a href="#_3-1-1-dom树与控件树" class="header-anchor">#</a> 3.1.1 DOM树与控件树</h4> <p>文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口，一种独立于平台和语言的方式访问和修改一个文档的内容和结构。换句话说，这是表示和处理一个HTML或XML文档的标准接口。简单来说，DOM就是文档树，与用户界面控件树对应，在前端开发中通常指HTML对应的渲染树，但广义的DOM也可以指Android中的XML布局文件对应的控件树，而术语DOM操作就是指直接来操作渲染树（或控件树）， 因此，可以看到其实DOM树和控件树是等价的概念，只不过前者常用于Web开发中，而后者常用于原生开发中。</p> <h4 id="_3-1-2-react中响应式编程"><a href="#_3-1-2-react中响应式编程" class="header-anchor">#</a> 3.1.2 React中响应式编程</h4> <ul><li>开发者只需关注状态转移（数据），当状态发生变化，React框架会自动根据新的状态重新构建UI。</li> <li>React框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过Diff算法，计算出树中变化的部分，然后只更新变化的部分（DOM操作），从而避免整棵树重构，提高性能。</li></ul> <p><code>值得注意的是</code>，在第二步中，状态变化后React框架并<code>不会</code>立即去计算并渲染DOM树的变化部分，相反，React会在DOM的基础上<code>建立一个抽象层</code>，即<code>虚拟DOM树</code>，对数据和状态所做的任何改动，都会被<code>自动</code>且<code>高效</code>的同步到<code>虚拟DOM</code>，最后再批量同步到<code>真实DOM</code>中，而不是每次改变都去操作一下DOM。为什么不能每次改变都直接去操作DOM树？这是因为在浏览器中每一次DOM操作都有可能引起浏览器的<code>重绘</code>或<code>回流</code>：</p> <ul><li><code>重绘界面</code> : 如果DOM只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。</li> <li><code>回流</code> : 如果DOM树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。</li></ul> <p>而浏览器的<code>重绘</code>和<code>回流</code>都是比较昂贵的操作，如果每一次改变都直接对DOM进行操作，这会带来性能问题，而批量操作只会触发一次DOM更新。</p> <h4 id="_3-1-3-react-native渲染"><a href="#_3-1-3-react-native渲染" class="header-anchor">#</a> 3.1.3 React Native渲染</h4> <p><strong>JavaScriptCore 是一个JavaScript解释器，它在React Native中主要有两个作用：</strong></p> <ul><li>为JavaScript提供运行环境。</li> <li>是JavaScript与原生应用之间通信的桥梁，作用和JsBridge一样，事实上，在iOS中，很多JsBridge的实现都是基于 JavaScriptCore 。</li></ul> <p><strong>而RN中将虚拟DOM映射为原生控件的过程中分两步：</strong></p> <ul><li>布局消息传递； 将虚拟DOM布局信息传递给原生；</li> <li>原生根据布局信息通过对应的原生控件渲染控件树；</li></ul> <p>React Native是原生控件渲染，所以性能会比混合应用中H5好很多，同时React Native是Web开发技术栈，也只需维护一份代码，同样是跨平台框架。</p> <h3 id="_3-2-weex"><a href="#_3-2-weex" class="header-anchor">#</a> 3.2 Weex</h3> <p>Weex是阿里巴巴于2016年发布的跨平台移动端开发框架，思想及原理和React Native类似，最大的不同是语法层面，Weex支持Vue语法和Rax语法，Rax 的 DSL(Domain Specific Language) 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。而React Native只支持JSX语法。</p> <h4 id="_3-2-1-快应用"><a href="#_3-2-1-快应用" class="header-anchor">#</a> 3.2.1 快应用</h4> <p>快应用是华为、小米、OPPO、魅族等国内9大主流手机厂商共同制定的轻量级应用标准，<code>目标直指微信小程序</code>。它也是采用JavaScript语言开发，原生控件渲染，与<code>React Native</code>和<code>Weex</code>相比主要有两点不同：</p> <ul><li>快应用自身不支持Vue或React语法，其采用原生JavaScript开发，其开发框架和微信小程序很像，值得一提的是小程序目前已经可以使用Vue语法开发（mpvue），从原理上来讲，Vue的语法也可以移植到快应用上。</li> <li>React Native和Weex的渲染/排版引擎是集成到框架中的，每一个APP都需要打包一份，安装包体积较大；而快应用渲染/排版引擎是集成到ROM中的，应用中无需打包，安装包体积小，正因如此，快应用才能在保证性能的同时做到快速分发。</li></ul> <h2 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h2> <p><strong>JavaScript开发+原生渲染的方式主要优点如下：</strong></p> <ul><li>采用Web开发技术栈，社区庞大、上手快、开发成本相对较低。</li> <li>原生渲染，性能相比H5提高很多。</li> <li>动态化较好，支持热更新。</li></ul> <p><strong>不足：</strong></p> <ul><li>渲染时需要JavaScript和原生之间通信，在有些场景如拖动可能会因为通信频繁导致卡顿。</li> <li>JavaScript为脚本语言，执行时需要JIT(Just In Time)，执行效率和AOT(Ahead Of Time)代码仍有差距。</li> <li>由于渲染依赖原生控件，不同平台的控件需要单独维护，并且当系统更新时，社区控件可能会滞后；除此之外，其控件系统也会受到原生UI系统限制，例如，在Android中，手势冲突消歧规则是固定的，这在使用不同人写的控件嵌套时，手势冲突问题将会变得非常棘手。</li></ul> <h2 id="_4、-自绘制引擎"><a href="#_4、-自绘制引擎" class="header-anchor">#</a> 4、 自绘制引擎</h2> <h3 id="_4-1-qt-mobile"><a href="#_4-1-qt-mobile" class="header-anchor">#</a> 4.1 QT Mobile</h3> <p>自绘UI+原生。这种技术的思路是，通过在不同平台实现一个统一接口的渲染引擎来绘制UI，而不依赖系统原生控件，所以可以做到不同平台UI的一致性。注意，自绘引擎解决的是UI的跨平台问题，如果涉及其它系统能力调用，依然要涉及原生开发。这种平台技术的优点如下：</p> <ul><li>性能高；由于自绘引擎是直接调用系统API来绘制UI，所以性能和原生控件接近。</li> <li>灵活、组件库易维护、UI外观保真度和一致性高；由于UI渲染不依赖原生控件，也就不需要根据不同平台的控件单独维护一套组件库，所以代码容易维护。由于组件库是同一套代码、同一个渲染引擎，所以在不同平台，组件显示外观可以做到高保真和高一致性；另外，由于不依赖原生控件，也就不会受原生布局系统的限制，这样布局系统会非常灵活。</li></ul> <p><strong>不足：</strong></p> <ul><li>动态性不足；为了保证UI绘制性能，自绘UI系统一般都会采用AOT模式编译其发布包，所以应用发布后，不能像Hybrid和RN那些使用JavaScript（JIT）作为开发语言的框架那样动态下发代码。</li> <li>开发效率低：QT使用C++作为其开发语言，而编程需要效率是直接会影响APP开发效率的，C++作为一门静态语言，在UI开发方面灵活性不及JavaScript这样的动态语言，另外，C++需要开发者手动去管理内存分配，没有JavaScript及Java中垃圾回收（GC）的机制。</li></ul> <p>Flutter正是实现一套自绘引擎，并拥有一套自己的UI布局系统。不过，<code>自绘制引擎的思路并不是什么新概念</code>，Flutter并不是第一个尝试这么做的，在它之前有一个典型的代表，即大名鼎鼎的QT。</p> <h4 id="_4-1-1-qt简介"><a href="#_4-1-1-qt简介" class="header-anchor">#</a> 4.1.1 QT简介</h4> <p>Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。2008年，Qt Company科技被诺基亚公司收购，Qt也因此成为诺基亚旗下的编程语言工具。2012年，Qt被Digia收购。2014年4月，跨平台集成开发环境Qt Creator 3.1.0正式发布，实现了对于iOS的完全支持，新增WinRT、Beautifier等插件，废弃了无Python接口的GDB调试支持，集成了基于Clang的C/C++代码模块，并对Android支持做出了调整，至此实现了全面支持iOS、Android、WP，它提供给应用程序开发者构建图形用户界面所需的所有功能。但是，QT虽然在PC端获得了巨大成功，备受社区追捧，然而其在移动端却表现不佳，在近几年，虽然偶尔能听到QT的声音，但一直很弱，无论QT本身技术如何、设计思想如何，但事实上终究是败了，究其原因，笔者认为主要有四：</p> <ul><li>QT移动开发社区太小，学习资料不足，生态不好。</li> <li>官方推广不利，支持不够。</li> <li>移动端发力较晚，市场已被其它动态化框架占领（Hybrid和RN)。</li> <li>在移动开发中，C++开发和Web开发栈相比有着先天的劣势，直接结果就是QT开发效率太低。</li></ul> <p>基于此四点，尽管QT是移动端开发跨平台自绘引擎的先驱，但却成为了烈士。</p> <h3 id="_4-2-flutter"><a href="#_4-2-flutter" class="header-anchor">#</a> 4.2 Flutter</h3> <h4 id="_4-2-1-flutter简介"><a href="#_4-2-1-flutter简介" class="header-anchor">#</a> 4.2.1 Flutter简介</h4> <p>Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展。同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验。</p> <ul><li>2017 年 Google I/O 大会上，Google 首次推出了一款新的用于创建跨平台、高性能的移动应用框架。</li> <li>2018年2月，Flutter发布了第一个Beta版本，同年五月， 在2018年Google I/O 大会上，Flutter 更新到了 beta 3 版本。</li> <li>2018年6月，Flutter发布了首个预览版本，这意味着 Flutter 进入了正式版（1.0）发布前的最后阶段。</li></ul> <h4 id="_4-2-2-跨平台自绘引擎"><a href="#_4-2-2-跨平台自绘引擎" class="header-anchor">#</a> 4.2.2 跨平台自绘引擎</h4> <p>Flutter与用于构建移动应用程序的其它大多数框架不同，因为Flutter既不使用WebView，也不使用操作系统的原生控件。 相反，Flutter使用自己的高性能渲染引擎来绘制widget。这样不仅可以保证在Android和iOS上UI的一致性，而且也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p> <p>Flutter使用Skia作为其2D渲染引擎，Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API，目前Google Chrome浏览器和Android均采用Skia作为其绘图引擎。</p> <p>目前Flutter目前默认支持iOS、Android、Fuchsia（Google新的自研操作系统）三个移动平台。但Flutter亦可支持Web开发（Flutter for web）和PC开发，本书的示例和介绍主要是基于iOS和Android平台的，其它平台读者可以自行了解。</p> <h4 id="_4-2-3-高性能"><a href="#_4-2-3-高性能" class="header-anchor">#</a> 4.2.3 高性能</h4> <p>Flutter高性能主要靠两点来保证，首先，Flutter APP采用Dart语言开发。Dart在 JIT（即时编译）模式下，速度与 JavaScript基本持平。但是 Dart支持 AOT，当以 AOT模式运行时，JavaScript便远远追不上了。速度的提升对高帧率下的视图数据计算很有帮助。其次，Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制，所以在布局过程中不需要像RN那样要在JavaScript和Native之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以JavaScript需要和Native之间不停的同步布局信息，这和在浏览器中要JavaScript频繁操作DOM所带来的问题是相同的，都会带来比较可观的性能开销。</p> <h4 id="_4-2-3-采用dart语言开发"><a href="#_4-2-3-采用dart语言开发" class="header-anchor">#</a> 4.2.3 采用Dart语言开发</h4> <p>这是一个很有意思，但也很有争议的问题，在了解<code>Flutter</code>为什么选择了 <code>Dart</code>而不是 <code>JavaScript</code>之前我们先来介绍两个概念：<code>JIT</code>和<code>AOT</code>。</p> <p>目前，程序主要有两种运行方式：<code>静态编译</code>与<code>动态解释</code>。</p> <ul><li><code>AOT</code>: 静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为<code>AOT （Ahead of time）</code>即 “<code>提前编译</code>”；</li> <li><code>JIT</code>: 而解释执行的则是一句一句边翻译边运行，通常将这种类型称为<code>JIT（Just-in-time）</code>即“<code>即时编译</code>”。</li></ul> <p><code>AOT</code>程序的典型代表是用<code>C/C++</code>开发的应用，它们必须在<code>执行前编译</code>成机器码，而<code>JIT</code>的代表则非常多，如<code>JavaScript</code>、<code>python</code>等，事实上，所有脚本语言都支持<code>JIT</code>模式。</p> <p>但需要注意的是<code>JIT</code>和<code>AOT</code>指的是<code>程序运行方式</code>，和编程语言并非强关联的，有些语言既可以以<code>JIT</code>方式运行也可以以<code>AOT</code>方式运行，如<code>Java</code>、<code>Python</code>，它们可以在第一次执行时编译成<code>中间字节码</code>、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将<code>字节码</code>转为<code>机器码</code>，是的，这没有错，不过通常我们<code>区分</code>是否为<code>AOT</code>的标准就是看代码在<code>执行之前是否需要编译</code>，只要需要编译，无论其编译产物是<code>字节码</code>还是<code>机器码</code>，都属于<code>AOT</code>。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p> <h3 id="_4-3-dart和javascript做一个对比"><a href="#_4-3-dart和javascript做一个对比" class="header-anchor">#</a> 4.3 Dart和JavaScript做一个对比</h3> <p>现在我们看看<code>Flutter</code>为什么选择<code>Dart</code>语言？笔者根据官方解释以及自己对<code>Flutter</code>的理解总结了以下几条（由于其它跨平台框架都将<code>JavaScript</code>作为其开发语言，所以主要将<code>Dart</code>和<code>JavaScript</code>做一个对比）：</p> <h4 id="开发效率高"><a href="#开发效率高" class="header-anchor">#</a> 开发效率高</h4> <p><code>Dart</code>运行时和编译器支持Flutter的两个关键特性的组合：</p> <p>基于<code>JIT</code>的快速开发周期：<code>Flutter</code>在开发阶段采用，采用<code>JIT</code>模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</p> <p>基于<code>AOT</code>的发布包: <code>Flutter</code>在发布时可以通过<code>AOT</code>生成高效的<code>ARM</code>代码以保证应用性能。而<code>JavaScript</code>则不具有这个能力。</p> <h4 id="高性能"><a href="#高性能" class="header-anchor">#</a> 高性能</h4> <p>Flutter旨在提供流畅、高保真的的UI体验。为了实现这一点，Flutter中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而Dart支持AOT，在这一点上可以做的比JavaScript更好。</p> <h4 id="快速内存分配"><a href="#快速内存分配" class="header-anchor">#</a> 快速内存分配</h4> <p>Flutter框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter将无法有效地工作。当然Chrome V8的JavaScript引擎在内存分配上也已经做的很好，事实上Dart开发团队的很多成员都是来自Chrome团队的，所以在内存分配上Dart并不能作为超越JavaScript的优势，而对于Flutter来说，它需要这样的特性，而Dart也正好满足而已。</p> <h4 id="类型安全"><a href="#类型安全" class="header-anchor">#</a> 类型安全</h4> <p>由于Dart是类型安全的语言，支持静态类型检测，所以可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript是一个弱类型语言，也因此前端社区出现了很多给JavaScript代码添加静态类型检测的扩展语言和工具，如：微软的TypeScript以及Facebook的Flow。相比之下，Dart本身就支持静态类型，这是它的一个重要优势。</p> <h4 id="dart团队就在你身边"><a href="#dart团队就在你身边" class="header-anchor">#</a> Dart团队就在你身边</h4> <p>看似不起眼，实则举足轻重。由于有Dart团队的积极投入，Flutter团队可以获得更多、更方便的支持，正如Flutter官网所述“我们正与Dart社区进行密切合作，以改进Dart在Flutter中的使用。例如，当我们最初采用Dart时，该语言并没有提供生成原生二进制文件的工具链（这对于实现可预测的高性能具有很大的帮助），但是现在它实现了，因为Dart团队专门为Flutter构建了它。同样，Dart VM之前已经针对吞吐量进行了优化，但团队现在正在优化VM的延迟时间，这对于Flutter的工作负载更为重要。”</p> <p>技术类型 UI渲染方式 性能 开发效率 动态化 框架代表 H5+原生 WebView渲染 一般 高 支持 Cordova、Ionic JavaScript+原生渲染 原生控件渲染 好 中 支持 RN、Weex 自绘UI+原生 调用系统API渲染 好 Flutter高, QT低 默认不支持 QT、Flutter</p> <h2 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h2> <table><thead><tr><th>技术类型级</th> <th>UI渲染方式</th> <th>性能</th> <th>开发效率</th> <th>动态化</th> <th>框架代表</th></tr></thead> <tbody><tr><td>H5+原生</td> <td>WebView渲染</td> <td>一般</td> <td>高</td> <td>支持</td> <td>Cordova、Ionic</td></tr> <tr><td>JavaScript+原生渲染</td> <td>原生控件渲染</td> <td>好</td> <td>中</td> <td>支持</td> <td>RN、Weex</td></tr> <tr><td>自绘UI+原生</td> <td>调用系统API渲染</td> <td>好</td> <td>F 高 QT低</td> <td>默认不支持</td> <td>QT、Flutter</td></tr></tbody></table> <p>上表中开发语言主要指UI的开发语言。而开发效率，是指整个开发周期的效率，包括编码时间、调试时间、以及排错、兼容时间。</p> <p><code>动态化</code>：主要指是否支持<code>动态下发代码</code>和<code>是否支持热更新</code>。</p> <p><code>值得注意的是</code>:Flutter的<code>Release</code>包默认是使用<code>Dart AOT模式编译</code>的，所以<code>不支持动态</code>化；</p> <p>但是<code>Dart</code>还有<code>JIT</code>或<code>snapshot</code>运行方式，这些模式都是<code>支持动态化</code>的。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/11/2021, 10:49:01 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/pages/knowledgeBase/node/" class="prev">
        node
      </a></span> <span class="next"><a href="/blog/pages/knowledgeBase/移动端/react-native/1.html">
        react-native
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.892c39d6.js" defer></script><script src="/blog/assets/js/2.312bc144.js" defer></script><script src="/blog/assets/js/66.751c0c8a.js" defer></script>
  </body>
</html>
