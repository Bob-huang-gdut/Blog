<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1. 循环打印红黄绿 | 黄思博前端进阶</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/images/logo.png">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <meta name="description" content="前端工程师,前端自学,高级前端工程师,中高级前端工程师,前端进阶知识,前端职业发展">
    
    <link rel="preload" href="/blog/assets/css/0.styles.e60b25d8.css" as="style"><link rel="preload" href="/blog/assets/js/app.bd9e66c9.js" as="script"><link rel="preload" href="/blog/assets/js/2.132bf881.js" as="script"><link rel="preload" href="/blog/assets/js/14.258dd0a6.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.a2d4c1a1.js"><link rel="prefetch" href="/blog/assets/js/11.4e199d04.js"><link rel="prefetch" href="/blog/assets/js/12.af9e9753.js"><link rel="prefetch" href="/blog/assets/js/13.2bb8ea25.js"><link rel="prefetch" href="/blog/assets/js/15.ea3d27a5.js"><link rel="prefetch" href="/blog/assets/js/16.e009ba4d.js"><link rel="prefetch" href="/blog/assets/js/17.a07415ea.js"><link rel="prefetch" href="/blog/assets/js/18.8dd78bf7.js"><link rel="prefetch" href="/blog/assets/js/19.95dd6708.js"><link rel="prefetch" href="/blog/assets/js/20.150bb104.js"><link rel="prefetch" href="/blog/assets/js/21.5d7dbb17.js"><link rel="prefetch" href="/blog/assets/js/22.efb69c4c.js"><link rel="prefetch" href="/blog/assets/js/23.39f491ae.js"><link rel="prefetch" href="/blog/assets/js/24.dcfe9fe3.js"><link rel="prefetch" href="/blog/assets/js/25.981000dd.js"><link rel="prefetch" href="/blog/assets/js/26.617cd5bc.js"><link rel="prefetch" href="/blog/assets/js/27.56920f0b.js"><link rel="prefetch" href="/blog/assets/js/28.befb5044.js"><link rel="prefetch" href="/blog/assets/js/29.4969b6f4.js"><link rel="prefetch" href="/blog/assets/js/3.b51f37ca.js"><link rel="prefetch" href="/blog/assets/js/30.2cbbf15a.js"><link rel="prefetch" href="/blog/assets/js/31.a83cd578.js"><link rel="prefetch" href="/blog/assets/js/32.8b71a959.js"><link rel="prefetch" href="/blog/assets/js/33.92ad7b6b.js"><link rel="prefetch" href="/blog/assets/js/34.d9e00f84.js"><link rel="prefetch" href="/blog/assets/js/35.62954c75.js"><link rel="prefetch" href="/blog/assets/js/36.2b9e1a54.js"><link rel="prefetch" href="/blog/assets/js/37.48d14464.js"><link rel="prefetch" href="/blog/assets/js/38.76a6d476.js"><link rel="prefetch" href="/blog/assets/js/39.dd707582.js"><link rel="prefetch" href="/blog/assets/js/4.9f518c74.js"><link rel="prefetch" href="/blog/assets/js/40.48cf2ad6.js"><link rel="prefetch" href="/blog/assets/js/41.1ceb0510.js"><link rel="prefetch" href="/blog/assets/js/42.bda6d241.js"><link rel="prefetch" href="/blog/assets/js/43.77429c8d.js"><link rel="prefetch" href="/blog/assets/js/44.de798060.js"><link rel="prefetch" href="/blog/assets/js/45.fee49181.js"><link rel="prefetch" href="/blog/assets/js/46.9ccb3e35.js"><link rel="prefetch" href="/blog/assets/js/47.814af934.js"><link rel="prefetch" href="/blog/assets/js/48.3f5acca7.js"><link rel="prefetch" href="/blog/assets/js/49.b2238c55.js"><link rel="prefetch" href="/blog/assets/js/5.8369cf44.js"><link rel="prefetch" href="/blog/assets/js/50.7e14e22c.js"><link rel="prefetch" href="/blog/assets/js/51.b951e531.js"><link rel="prefetch" href="/blog/assets/js/52.82750939.js"><link rel="prefetch" href="/blog/assets/js/53.78a7ad63.js"><link rel="prefetch" href="/blog/assets/js/54.dfa28673.js"><link rel="prefetch" href="/blog/assets/js/55.10e3b8ba.js"><link rel="prefetch" href="/blog/assets/js/56.f9532bd1.js"><link rel="prefetch" href="/blog/assets/js/57.d6769e64.js"><link rel="prefetch" href="/blog/assets/js/58.3ef27942.js"><link rel="prefetch" href="/blog/assets/js/59.4dbc8001.js"><link rel="prefetch" href="/blog/assets/js/6.67fb8021.js"><link rel="prefetch" href="/blog/assets/js/60.65bd3624.js"><link rel="prefetch" href="/blog/assets/js/61.e77ed095.js"><link rel="prefetch" href="/blog/assets/js/62.ba4dc878.js"><link rel="prefetch" href="/blog/assets/js/63.683212a2.js"><link rel="prefetch" href="/blog/assets/js/64.71e44fb5.js"><link rel="prefetch" href="/blog/assets/js/65.9ffbfa85.js"><link rel="prefetch" href="/blog/assets/js/66.5afc912f.js"><link rel="prefetch" href="/blog/assets/js/67.3d83e17c.js"><link rel="prefetch" href="/blog/assets/js/68.ff91c12c.js"><link rel="prefetch" href="/blog/assets/js/69.42cdb20b.js"><link rel="prefetch" href="/blog/assets/js/7.90f4ae40.js"><link rel="prefetch" href="/blog/assets/js/70.593f7c1b.js"><link rel="prefetch" href="/blog/assets/js/8.c559eeab.js"><link rel="prefetch" href="/blog/assets/js/9.3f8c1dcf.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.e60b25d8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/images/logo.png" alt="黄思博前端进阶" class="logo"> <span class="site-name can-hide">黄思博前端进阶</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><a href="/blog/pages/summary/" class="nav-link">
  个人总结
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/pages/knowledgeBase/" class="nav-link router-link-active">
  知识库
</a></div><div class="nav-item"><a href="/blog/pages/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/blog/pages/question/" class="nav-link">
  每日·一题
</a></div><div class="nav-item"><a href="/blog/pages/summary/" class="nav-link">
  个人总结
</a></div><div class="nav-item"><a href="https://github.com/Bob-huang-gdut" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/pages/knowledgeBase/" aria-current="page" class="sidebar-link">知识库</a></li><li><a href="/blog/pages/knowledgeBase/html/" class="sidebar-link">html</a></li><li><a href="/blog/pages/knowledgeBase/css/" class="sidebar-link">css</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>react</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/typeScript/" class="sidebar-link">typeScript</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/blog/pages/knowledgeBase/browser/" class="sidebar-link">浏览器</a></li><li><a href="/blog/pages/knowledgeBase/network/" class="sidebar-link">计算机网络</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>rollup</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>手写代码</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/knowledgeBase/code/1.html" class="sidebar-link">一、JavaScript基础</a></li><li><a href="/blog/pages/knowledgeBase/code/2.html" class="sidebar-link">二、数据处理</a></li><li><a href="/blog/pages/knowledgeBase/code/3.html" aria-current="page" class="active sidebar-link">三、应用场景</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端安全</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_1-循环打印红黄绿"><a href="#_1-循环打印红黄绿" class="header-anchor">#</a> 1. 循环打印红黄绿</h3> <p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p> <p>三个亮灯函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function red() {
    console.log('red');
}
function green() {
    console.log('green');
}
function yellow() {
    console.log('yellow');
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p> <h4 id="_1-用-callback-实现"><a href="#_1-用-callback-实现" class="header-anchor">#</a> （1）用 callback 实现</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const task = (timer, light, callback) =&gt; {
    setTimeout(() =&gt; {
        if (light === 'red') {
            red()
        }
        else if (light === 'green') {
            green()
        }
        else if (light === 'yellow') {
            yellow()
        }
        callback()
    }, timer)
}
task(3000, 'red', () =&gt; {
    task(2000, 'green', () =&gt; {
        task(1000, 'yellow', Function.prototype)
    })
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p> <p>上面提到过递归，可以递归亮灯的一个周期：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const step = () =&gt; {
    task(3000, 'red', () =&gt; {
        task(2000, 'green', () =&gt; {
            task(1000, 'yellow', step)
        })
    })
}
step()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p> <h4 id="_2-用-promise-实现"><a href="#_2-用-promise-实现" class="header-anchor">#</a> （2）用 promise 实现</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const task = (timer, light) =&gt; 
    new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })
const step = () =&gt; {
    task(3000, 'red')
        .then(() =&gt; task(2000, 'green'))
        .then(() =&gt; task(2100, 'yellow'))
        .then(step)
}
step()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p> <h4 id="_3-用-async-await-实现"><a href="#_3-用-async-await-实现" class="header-anchor">#</a> （3）用 async/await 实现</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>const taskRunner =  async () =&gt; {
    await task(3000, 'red')
    await task(2000, 'green')
    await task(2100, 'yellow')
    taskRunner()
}
taskRunner()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_2-实现每隔一秒打印-1-2-3-4"><a href="#_2-实现每隔一秒打印-1-2-3-4" class="header-anchor">#</a> 2. 实现每隔一秒打印 1,2,3,4</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 使用闭包实现
for (var i = 0; i &lt; 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
// 使用 let 块级作用域
for (let i = 0; i &lt; 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_3-小孩报数问题"><a href="#_3-小孩报数问题" class="header-anchor">#</a> 3. 小孩报数问题</h3> <p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function childNum(num, count){
    let allplayer = [];    
    for(let i = 0; i &lt; num; i++){
        allplayer[i] = i + 1;
    }
    
    let exitCount = 0;    // 离开人数
    let counter = 0;      // 记录报数
    let curIndex = 0;     // 当前下标
    
    while(exitCount &lt; num - 1){
        if(allplayer[curIndex] !== 0) counter++;    
        
        if(counter == count){
            allplayer[curIndex] = 0;                 
            counter = 0;
            exitCount++;  
        }
        curIndex++;
        if(curIndex == num){
            curIndex = 0               
        };           
    }    
    for(i = 0; i &lt; num; i++){
        if(allplayer[i] !== 0){
            return allplayer[i]
        }      
    }
}
childNum(30, 3)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h3 id="_4-用promise实现图片的异步加载"><a href="#_4-用promise实现图片的异步加载" class="header-anchor">#</a> 4. 用Promise实现图片的异步加载</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>let imageAsync=(url)=&gt;{
            return new Promise((resolve,reject)=&gt;{
                let img = new Image();
                img.src = url;
                img.οnlοad=()=&gt;{
                    console.log(`图片请求成功，此处进行通用操作`);
                    resolve(image);
                }
                img.οnerrοr=(err)=&gt;{
                    console.log(`失败，此处进行失败的通用操作`);
                    reject(err);
                }
            })
        }
        
imageAsync(&quot;url&quot;).then(()=&gt;{
    console.log(&quot;加载成功&quot;);
}).catch((error)=&gt;{
    console.log(&quot;加载失败&quot;);
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_5-实现发布-订阅模式"><a href="#_5-实现发布-订阅模式" class="header-anchor">#</a> 5. 实现发布-订阅模式</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>class EventCenter{
  // 1. 定义事件容器，用来装事件数组
	let handlers = {}

  // 2. 添加事件方法，参数：事件名 事件方法
  addEventListener(type, handler) {
    // 创建新数组容器
    if (!this.handlers[type]) {
      this.handlers[type] = []
    }
    // 存入事件
    this.handlers[type].push(handler)
  }

  // 3. 触发事件，参数：事件名 事件参数
  dispatchEvent(type, params) {
    // 若没有注册该事件则抛出错误
    if (!this.handlers[type]) {
      return new Error('该事件未注册')
    }
    // 触发事件
    this.handlers[type].forEach(handler =&gt; {
      handler(...params)
    })
  }

  // 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布
  removeEventListener(type, handler) {
    if (!this.handlers[type]) {
      return new Error('事件无效')
    }
    if (!handler) {
      // 移除事件
      delete this.handlers[type]
    } else {
      const index = this.handlers[type].findIndex(el =&gt; el === handler)
      if (index === -1) {
        return new Error('无该绑定事件')
      }
      // 移除事件
      this.handlers[type].splice(index, 1)
      if (this.handlers[type].length === 0) {
        delete this.handlers[type]
      }
    }
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><h3 id="_6-查找文章中出现频率最高的单词"><a href="#_6-查找文章中出现频率最高的单词" class="header-anchor">#</a> 6. 查找文章中出现频率最高的单词</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>function findMostWord(article) {
  // 合法性判断
  if (!article) return;
  // 参数处理
  article = article.trim().toLowerCase();
  let wordList = article.match(/[a-z]+/g),
    visited = [],
    maxNum = 0,
    maxWord = &quot;&quot;;
  article = &quot; &quot; + wordList.join(&quot;  &quot;) + &quot; &quot;;
  // 遍历判断单词出现次数
  wordList.forEach(function(item) {
    if (visited.indexOf(item) &lt; 0) {
      // 加入 visited 
      visited.push(item);
      let word = new RegExp(&quot; &quot; + item + &quot; &quot;, &quot;g&quot;),
        num = article.match(word).length;
      if (num &gt; maxNum) {
        maxNum = num;
        maxWord = item;
      }
    }
  });
  return maxWord + &quot;  &quot; + maxNum;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="_7-封装异步的fetch-使用async-await方式来使用"><a href="#_7-封装异步的fetch-使用async-await方式来使用" class="header-anchor">#</a> 7. 封装异步的fetch，使用async await方式来使用</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>(async () =&gt; {
    class HttpRequestUtil {
        async get(url) {
            const res = await fetch(url);
            const data = await res.json();
            return data;
        }
        async post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async put(url, data) {
            const res = await fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
        async delete(url, data) {
            const res = await fetch(url, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: JSON.stringify(data)
            });
            const result = await res.json();
            return result;
        }
    }
    const httpRequestUtil = new HttpRequestUtil();
    const res = await httpRequestUtil.get('http://golderbrother.cn/');
    console.log(res);
})();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="_8-实现prototype继承"><a href="#_8-实现prototype继承" class="header-anchor">#</a> 8. 实现prototype继承</h3> <p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//父方法
function SupperFunction(flag1){
    this.flag1 = flag1;
}

//子方法
function SubFunction(flag2){
    this.flag2 = flag2;
}

//父实例
var superInstance = new SupperFunction(true);

//子继承父
SubFunction.prototype = superInstance;

//子实例
var subInstance = new SubFunction(false);
//子调用自己和父的属性
subInstance.flag1;   // true
subInstance.flag2;   // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="_9-实现双向数据绑定"><a href="#_9-实现双向数据绑定" class="header-anchor">#</a> 9. 实现双向数据绑定</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
  configurable: true,
  enumerable: true,
  get() {
    console.log('获取数据了')
  },
  set(newVal) {
    console.log('数据更新了')
    input.value = newVal
    span.innerHTML = newVal
  }
})
// 输入监听
input.addEventListener('keyup', function(e) {
  obj.text = e.target.value
})
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="_10-实现简单路由"><a href="#_10-实现简单路由" class="header-anchor">#</a> 10. 实现简单路由</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// hash路由
class Route{
  constructor(){
    // 路由存储对象
    this.routes = {}
    // 当前hash
    this.currentHash = ''
    // 绑定this，避免监听时this指向改变
    this.freshRoute = this.freshRoute.bind(this)
    // 监听
    window.addEventListener('load', this.freshRoute, false)
    window.addEventListener('hashchange', this.freshRoute, false)
  }
  // 存储
  storeRoute (path, cb) {
    this.routes[path] = cb || function () {}
  }
  // 更新
  freshRoute () {
    this.currentHash = location.hash.slice(1) || '/'
    this.routes[this.currentHash]()
  }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="_11-实现斐波那契数列"><a href="#_11-实现斐波那契数列" class="header-anchor">#</a> 11. 实现斐波那契数列</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 递归
function fn (n){
    if(n==0) return 0
    if(n==1) return 1
    return fn(n-2)+fn(n-1)
}
// 优化
function fibonacci2(n) {
    const arr = [1, 1, 2];
    const arrLen = arr.length;

    if (n &lt;= arrLen) {
        return arr[n];
    }

    for (let i = arrLen; i &lt; n; i++) {
        arr.push(arr[i - 1] + arr[ i - 2]);
    }

    return arr[arr.length - 1];
}
// 非递归
function fn(n) {
    let pre1 = 1;
    let pre2 = 1;
    let current = 2;

    if (n &lt;= 2) {
        return current;
    }

    for (let i = 2; i &lt; n; i++) {
        pre1 = pre2;
        pre2 = current;
        current = pre1 + pre2;
    }

    return current;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><h3 id="_12-字符串出现的不重复最长长度"><a href="#_12-字符串出现的不重复最长长度" class="header-anchor">#</a> 12. 字符串出现的不重复最长长度</h3> <p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var lengthOfLongestSubstring = function (s) {
    let map = new Map();
    let i = -1
    let res = 0
    let n = s.length
    for (let j = 0; j &lt; n; j++) {
        if (map.has(s[j])) {
            i = Math.max(i, map.get(s[j]))
        }
        res = Math.max(res, j - i)
        map.set(s[j], j)
    }
    return res
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_13-使用-settimeout-实现-setinterval"><a href="#_13-使用-settimeout-实现-setinterval" class="header-anchor">#</a> 13. 使用 setTimeout 实现 setInterval</h3> <p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p> <p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p> <p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true
  };
  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }
  // 启动定时器
  setTimeout(interval, timeout);
  // 返回控制器
  return timer;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h3 id="_14-实现-jsonp"><a href="#_14-实现-jsonp" class="header-anchor">#</a> 14. 实现 jsonp</h3> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 动态的加载js文件
function addScript(src) {
  const script = document.createElement('script');
  script.src = src;
  script.type = &quot;text/javascript&quot;;
  document.body.appendChild(script);
}
addScript(&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;);
// 设置一个全局的callback函数来接收回调结果
function handleRes(res) {
  console.log(res);
}
// 接口返回的数据格式
handleRes({a: 1, b: 2});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="_15-判断对象是否存在循环引用"><a href="#_15-判断对象是否存在循环引用" class="header-anchor">#</a> 15. 判断对象是否存在循环引用</h3> <p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p> <p>下面方法可以用来判断一个对象中是否已存在循环引用：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const isCycleObject = (obj,parent) =&gt; {
    const parentArr = parent || [obj];
    for(let i in obj) {
        if(typeof obj[i] === 'object') {
            let flag = false;
            parentArr.forEach((pObj) =&gt; {
                if(pObj === obj[i]){
                    flag = true;
                }
            })
            if(flag) return true;
            flag = isCycleObject(obj[i],[...parentArr,obj[i]]);
            if(flag) return true;
        }
    }
    return false;
}


const a = 1;
const b = {a};
const c = {b};
const o = {d:{a:3},c}
o.c.b.aa = a;

console.log(isCycleObject(o)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>查找有序二维数组的目标值：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var findNumberIn2DArray = function(matrix, target) {
    if (matrix == null || matrix.length == 0) {
        return false;
    }
    let row = 0;
    let column = matrix[0].length - 1;
    while (row &lt; matrix.length &amp;&amp; column &gt;= 0) {
        if (matrix[row][column] == target) {
            return true;
        } else if (matrix[row][column] &gt; target) {
            column--;
        } else {
            row++;
        }
    }
    return false;
};

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>二维数组斜向打印：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function printMatrix(arr){
  let m = arr.length, n = arr[0].length
	let res = []
  
  // 左上角，从0 到 n - 1 列进行打印
  for (let k = 0; k &lt; n; k++) {
    for (let i = 0, j = k; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) {
      res.push(arr[i][j]);
    }
  }

  // 右下角，从1 到 n - 1 行进行打印
  for (let k = 1; k &lt; m; k++) {
    for (let i = k, j = n - 1; i &lt; m &amp;&amp; j &gt;= 0; i++, j--) {
      res.push(arr[i][j]);
    }
  }
  return res
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/5/2021, 12:32:29 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/pages/knowledgeBase/code/2.html" class="prev">
        二、数据处理
      </a></span> <span class="next"><a href="/blog/pages/knowledgeBase/security/1.html">
        前端安全
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.bd9e66c9.js" defer></script><script src="/blog/assets/js/2.132bf881.js" defer></script><script src="/blog/assets/js/14.258dd0a6.js" defer></script>
  </body>
</html>
